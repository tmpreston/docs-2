{
    "docs": [
        {
            "location": "/",
            "text": "Saturn\n\n\nSaturn is a web development framework written in F# which implements the server-side MVC pattern. Many of its components and concepts will seem familiar to those of us with experience in other web frameworks like Ruby on Rails or Python\u2019s Django.\n\n\nIt's heavily inspired by Elixir's \nPhoenix\n.\n\n\nRead more about why I've decided to create Saturn, and some of its design choices on my blog - \nhttp://kcieslak.io/Reinventing-MVC-for-web-programming-with-F\n\n\nSaturn rings\n\n\nSaturn itself is the top layer of a multi-layer system designed to create a flexible, productive environment for creating web applications.\n\n\nKestrel and ASP.NET Core\n\n\n\n\nASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-based, Internet-connected applications\n\n\nKestrel is a cross-platform web server for ASP.NET Core based on libuv, a cross-platform asynchronous I/O library\n\n\n\n\nGiraffe\n\n\n\n\nGiraffe is an F# micro web framework for building rich web applications. It has been heavily inspired and is similar to \nSuave\n, but has been specifically designed with ASP.NET Core in mind and can be plugged into the ASP.NET Core pipeline via middleware. Giraffe applications are composed of so-called HttpHandler functions which can be thought of as a mixture of Suave's WebParts and ASP.NET Core's middleware.\n\n\n\n\nSaturn moons\n\n\nSaturn is not only a library building on top of Giraffe, but also a set of opinionated tooling for scaffolding a whole project and then generating some boilerplate code. At the moment our template is using (by default):\n\n\nDapper\n\n\n\n\na simple, focused on performance object mapper for .Net that you can add in to your project and will extend your \nIDbConnection\n interface.\n\n\n\n\nSimple.Migrations\n\n\n\n\nSimple.Migrations is a simple bare-bones migration framework for .NET Core (.NET Standard 1.2 and .NET 4.5). It doesn't provide SQL generation, nor an out-of-the-box command-line tool, nor any other fancy feature. It does however provide a set of simple, extendable, and composable tools for integrating migrations into your application.\n\n\n\n\nOverview\n\n\nBuilt on top of the battle-tested ASP.NET Core foundation and the highly flexible, extendable model of Giraffe, Saturn provides high level abstractions, helpers and tools to enable high developer productivity, at the same time keeping high application performance provided by Kestrel and Giraffe.\n\n\nSaturn is made up of a number of distinct parts, each with its own purpose and role to play in building a web application.\n\n\n\n\nApplication\n\n\nthe start and end of the request life cycle\n\n\nhandles all aspects of requests up until the point where the router takes over\n\n\nprovides a core set of plugs to apply to all requests\n\n\ndispatches requests into a router\n\n\nenables application and hosting configuration\n\n\n\n\n\n\nRouter\n\n\nparses incoming requests and dispatches them to the correct controller/action, passing parameters as needed\n\n\nprovides helpers to generate route paths or urls to resources\n\n\ndefines named pipelines through which we may pass our requests\n\n\nallows easy application of groups of plugs to a set of routes\n\n\n\n\n\n\nControllers\n\n\nprovide functions, called \nactions\n, to handle requests\n\n\nactions:\n\n\nprepare data and pass it into views\n\n\ninvoke rendering via views\n\n\nperform redirects\n\n\nreturn data as JSON or XML\n\n\nand much more\n\n\n\n\n\n\n\n\n\n\nViews\n\n\nrender templates\n\n\nact as a presentation layer\n\n\ndefine helper functions, available in templates, to decorate data for presentation\n\n\n\n\n\n\nChannels  \n[Not implemented yet]\n\n\nmanage sockets for easy realtime communication\n\n\nare analogous to controllers except that they allow bi-directional communication with persistent connections\n\n\n\n\n\n\nScaffolding scripts\n\n\ndotnet new\n template providing good starting point for new applications - \nhttps://github.com/SaturnFramework/Saturn.Template\n\n\ndotnet saturn\n CLI tool that controls migrations and let you easily scaffold new parts of application - \nhttps://github.com/SaturnFramework/Saturn.Dotnet\n\n\n\n\n\n\n\n\n\n\nHow to contribute\n\n\nImposter syndrome disclaimer\n: I want your help. No really, I do.\n\n\nThere might be a little voice inside that tells you you're not ready; that you need to do one more tutorial, or learn another framework, or write a few more blog posts before you can help me with this project.\n\n\nI assure you, that's not the case.\n\n\nThis project has some clear Contribution Guidelines and expectations that you can \nread here\n.\n\n\nThe contribution guidelines outline the process that you'll need to follow to get a patch merged. By making expectations and process explicit, I hope it will make it easier for you to contribute.\n\n\nAnd you don't just have to write code. You can help out by writing documentation, tests, or even by giving feedback about this work. (And yes, that includes giving feedback about the contribution guidelines.)\n\n\nThank you for contributing!\n\n\nContributing and copyright\n\n\nThe project is hosted on \nGitHub\n where you can \nreport issues\n, fork\nthe project and submit pull requests.\n\n\nThe library is available under \nMIT license\n, which allows modification and redistribution for both commercial and non-commercial purposes.",
            "title": "Home"
        },
        {
            "location": "/#saturn",
            "text": "Saturn is a web development framework written in F# which implements the server-side MVC pattern. Many of its components and concepts will seem familiar to those of us with experience in other web frameworks like Ruby on Rails or Python\u2019s Django.  It's heavily inspired by Elixir's  Phoenix .  Read more about why I've decided to create Saturn, and some of its design choices on my blog -  http://kcieslak.io/Reinventing-MVC-for-web-programming-with-F",
            "title": "Saturn"
        },
        {
            "location": "/#saturn-rings",
            "text": "Saturn itself is the top layer of a multi-layer system designed to create a flexible, productive environment for creating web applications.",
            "title": "Saturn rings"
        },
        {
            "location": "/#kestrel-and-aspnet-core",
            "text": "ASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-based, Internet-connected applications  Kestrel is a cross-platform web server for ASP.NET Core based on libuv, a cross-platform asynchronous I/O library",
            "title": "Kestrel and ASP.NET Core"
        },
        {
            "location": "/#giraffe",
            "text": "Giraffe is an F# micro web framework for building rich web applications. It has been heavily inspired and is similar to  Suave , but has been specifically designed with ASP.NET Core in mind and can be plugged into the ASP.NET Core pipeline via middleware. Giraffe applications are composed of so-called HttpHandler functions which can be thought of as a mixture of Suave's WebParts and ASP.NET Core's middleware.",
            "title": "Giraffe"
        },
        {
            "location": "/#saturn-moons",
            "text": "Saturn is not only a library building on top of Giraffe, but also a set of opinionated tooling for scaffolding a whole project and then generating some boilerplate code. At the moment our template is using (by default):",
            "title": "Saturn moons"
        },
        {
            "location": "/#dapper",
            "text": "a simple, focused on performance object mapper for .Net that you can add in to your project and will extend your  IDbConnection  interface.",
            "title": "Dapper"
        },
        {
            "location": "/#simplemigrations",
            "text": "Simple.Migrations is a simple bare-bones migration framework for .NET Core (.NET Standard 1.2 and .NET 4.5). It doesn't provide SQL generation, nor an out-of-the-box command-line tool, nor any other fancy feature. It does however provide a set of simple, extendable, and composable tools for integrating migrations into your application.",
            "title": "Simple.Migrations"
        },
        {
            "location": "/#overview",
            "text": "Built on top of the battle-tested ASP.NET Core foundation and the highly flexible, extendable model of Giraffe, Saturn provides high level abstractions, helpers and tools to enable high developer productivity, at the same time keeping high application performance provided by Kestrel and Giraffe.  Saturn is made up of a number of distinct parts, each with its own purpose and role to play in building a web application.   Application  the start and end of the request life cycle  handles all aspects of requests up until the point where the router takes over  provides a core set of plugs to apply to all requests  dispatches requests into a router  enables application and hosting configuration    Router  parses incoming requests and dispatches them to the correct controller/action, passing parameters as needed  provides helpers to generate route paths or urls to resources  defines named pipelines through which we may pass our requests  allows easy application of groups of plugs to a set of routes    Controllers  provide functions, called  actions , to handle requests  actions:  prepare data and pass it into views  invoke rendering via views  perform redirects  return data as JSON or XML  and much more      Views  render templates  act as a presentation layer  define helper functions, available in templates, to decorate data for presentation    Channels   [Not implemented yet]  manage sockets for easy realtime communication  are analogous to controllers except that they allow bi-directional communication with persistent connections    Scaffolding scripts  dotnet new  template providing good starting point for new applications -  https://github.com/SaturnFramework/Saturn.Template  dotnet saturn  CLI tool that controls migrations and let you easily scaffold new parts of application -  https://github.com/SaturnFramework/Saturn.Dotnet",
            "title": "Overview"
        },
        {
            "location": "/#how-to-contribute",
            "text": "Imposter syndrome disclaimer : I want your help. No really, I do.  There might be a little voice inside that tells you you're not ready; that you need to do one more tutorial, or learn another framework, or write a few more blog posts before you can help me with this project.  I assure you, that's not the case.  This project has some clear Contribution Guidelines and expectations that you can  read here .  The contribution guidelines outline the process that you'll need to follow to get a patch merged. By making expectations and process explicit, I hope it will make it easier for you to contribute.  And you don't just have to write code. You can help out by writing documentation, tests, or even by giving feedback about this work. (And yes, that includes giving feedback about the contribution guidelines.)  Thank you for contributing!",
            "title": "How to contribute"
        },
        {
            "location": "/#contributing-and-copyright",
            "text": "The project is hosted on  GitHub  where you can  report issues , fork\nthe project and submit pull requests.  The library is available under  MIT license , which allows modification and redistribution for both commercial and non-commercial purposes.",
            "title": "Contributing and copyright"
        },
        {
            "location": "/guides/how-to-start/",
            "text": "How to start in 60 seconds\n\n\nRequirements:\n\n\n\n\ndotnet\n SDK\n\n\nmono\n (on Linux/MacOS)\n\n\nfake\n\n\n\n\n\n\n\n\nInstall the \ndotnet\n template with \ndotnet new -i Saturn.Template\n\n\nCreate a new folder and move into it - \nmkdir SaturnSample && cd SaturnSample\n\n\nCreate a new Saturn application - \ndotnet new saturn -lang F#\n\n\nRun the build process to ensure everything was scaffolded correctly and restore dependencies - \nfake build\n\n\nGo into the subdirectory with the server application - \ncd src/SaturnSample\n\n\nCreate a new controller with \ndotnet saturn gen Book Books id:string title:string author:string\n\n\nRun migrations that will create the database and Books table (as for now, the generator is using only SQLite DB) - \ndotnet saturn migration\n\n\nOpen the folder in your favourite editor (VSCode) and insert the line (\nforward \"/books\" Books.Controller.resource\n) into \nbrowserRouter\n in \nRouter.fs\n file\n\n\nStart the application by running \nfake build -t run\n from the root of the solution. This will start the application in watch mode (automatic recompilation on changes) and open your browser on \nhttp://localhost:8085\n which should display the index page.\n\n\nGo to \nhttp://localhost:8085/books\n to see the generated view. All buttons should be working; you can add new entries, and remove or edit old ones.",
            "title": "How to start in 60 seconds"
        },
        {
            "location": "/guides/how-to-start/#how-to-start-in-60-seconds",
            "text": "Requirements:   dotnet  SDK  mono  (on Linux/MacOS)  fake     Install the  dotnet  template with  dotnet new -i Saturn.Template  Create a new folder and move into it -  mkdir SaturnSample && cd SaturnSample  Create a new Saturn application -  dotnet new saturn -lang F#  Run the build process to ensure everything was scaffolded correctly and restore dependencies -  fake build  Go into the subdirectory with the server application -  cd src/SaturnSample  Create a new controller with  dotnet saturn gen Book Books id:string title:string author:string  Run migrations that will create the database and Books table (as for now, the generator is using only SQLite DB) -  dotnet saturn migration  Open the folder in your favourite editor (VSCode) and insert the line ( forward \"/books\" Books.Controller.resource ) into  browserRouter  in  Router.fs  file  Start the application by running  fake build -t run  from the root of the solution. This will start the application in watch mode (automatic recompilation on changes) and open your browser on  http://localhost:8085  which should display the index page.  Go to  http://localhost:8085/books  to see the generated view. All buttons should be working; you can add new entries, and remove or edit old ones.",
            "title": "How to start in 60 seconds"
        },
        {
            "location": "/guides/directory-structure/",
            "text": "Directory Structure\n\n\nAfter creating a new Saturn project, let's take a deeper look into what files are created.\n\n\n\u251c\u2500\u2500 .fake\n\u251c\u2500\u2500 .paket\n\u251c\u2500\u2500 .vs\n\u251c\u2500\u2500 .packages\n\u251c\u2500\u2500 paket-files\n\u251c\u2500\u2500 src\n|   \u251c\u2500\u2500 Migrations\n|   \u2514\u2500\u2500 SaturnSample\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 build.cmd\n\u251c\u2500\u2500 build.fsx\n\u251c\u2500\u2500 build.sh\n\u251c\u2500\u2500 global.json\n\u251c\u2500\u2500 paket.dependencies\n\u251c\u2500\u2500 paket.lock\n\u2514\u2500\u2500 SaturnSample.sln\n\n\n\nAt this level most of it is basic configuration files to help with running Saturn. From looking at the \n.paket\n, \npaket-files\n, \npaket.dependencies\n, \npaket.lock\n folders and files, you can see that by default Saturn uses \npaket\n to handle package management. You won't be working with these files directly but rather through the command line tools instead.\n\n\nSaturn also uses \nFAKE\n to build the project. You can see how it is set up by looking at the \n.fake\n folder and the \nbuild.cmd\n, \nbuild.fsx\n, \nbuild.sh\n files.\n\n\nSaturn also provides a \n.gitignore\n file that prevents some folders from being tracked by git when they don't need to.\n\n\nLastly, there is the \nSaturnSample.sln\n solution file so you can open the project in an IDE like Visual Sudio and a \nglobal.json\n file to configure the solution file.\n\n\nMost of the work you will do in this project however, will be in \nsrc/SaturnSample\n, which looks like the following when expanded:\n\n\n\u251c\u2500\u2500 bin\n\u251c\u2500\u2500 Books\n|   \u251c\u2500\u2500 BooksController.fs\n|   \u251c\u2500\u2500 BooksModel.fs\n|   \u251c\u2500\u2500 BooksRepository.fs\n|   \u2514\u2500\u2500 BooksView.fs\n\u251c\u2500\u2500 obj\n\u251c\u2500\u2500 static\n|   \u251c\u2500\u2500 app.css\n|   \u2514\u2500\u2500 app.js\n\u251c\u2500\u2500 Templates\n|   \u251c\u2500\u2500 App.fs\n|   \u251c\u2500\u2500 Index.fs\n|   \u251c\u2500\u2500 InternalError.fs\n|   \u2514\u2500\u2500 NotFound.fs\n\u251c\u2500\u2500 Config.fs\n\u251c\u2500\u2500 Database.fs\n\u251c\u2500\u2500 database.sqlite\n\u251c\u2500\u2500 paket.references\n\u251c\u2500\u2500 Program.fs\n\u251c\u2500\u2500 Router.fs\n\u2514\u2500\u2500 SaturnSample.fsproj\n\n\n\nbin\n and \nobj\n folders store the compiled version of the program after you build the project.\n\n\nThe convention for Saturn is that the model and everything associated with it are inside one folder. Everything is also named with the plural form of the model so \"Books\" instead of \"Book\".\n\n\nYour static files like css, js, and images should be inside the \nstatic\n folder.\n\n\nConfig.fs\n contains a \nConfig\n record that stores settings that you can use inside your application. By default, the record only contains the \nconnectionString\n field.\n\n\nDatabase.fs\n contains functions to execute SQL queries within the program through \nDapper\n.\n\n\nIf you did not run \ndotnet saturn migration\n as in the \nhow to start guide\n, you might not see \ndatabase.sqlite\n, but that is the database file that your Saturn project is using to store data.\n\n\npaket.references\n shows the packages that your project is using.\n\n\nProgram.fs\n handles intializing the program and loading up various settings.\n\n\nRouter.fs\n is where you will set the route of the site and what page to load.\n\n\nLastly, \nSaturnSample.fsproj\n is the project file itself.",
            "title": "Directory Structure"
        },
        {
            "location": "/guides/directory-structure/#directory-structure",
            "text": "After creating a new Saturn project, let's take a deeper look into what files are created.  \u251c\u2500\u2500 .fake\n\u251c\u2500\u2500 .paket\n\u251c\u2500\u2500 .vs\n\u251c\u2500\u2500 .packages\n\u251c\u2500\u2500 paket-files\n\u251c\u2500\u2500 src\n|   \u251c\u2500\u2500 Migrations\n|   \u2514\u2500\u2500 SaturnSample\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 build.cmd\n\u251c\u2500\u2500 build.fsx\n\u251c\u2500\u2500 build.sh\n\u251c\u2500\u2500 global.json\n\u251c\u2500\u2500 paket.dependencies\n\u251c\u2500\u2500 paket.lock\n\u2514\u2500\u2500 SaturnSample.sln  At this level most of it is basic configuration files to help with running Saturn. From looking at the  .paket ,  paket-files ,  paket.dependencies ,  paket.lock  folders and files, you can see that by default Saturn uses  paket  to handle package management. You won't be working with these files directly but rather through the command line tools instead.  Saturn also uses  FAKE  to build the project. You can see how it is set up by looking at the  .fake  folder and the  build.cmd ,  build.fsx ,  build.sh  files.  Saturn also provides a  .gitignore  file that prevents some folders from being tracked by git when they don't need to.  Lastly, there is the  SaturnSample.sln  solution file so you can open the project in an IDE like Visual Sudio and a  global.json  file to configure the solution file.  Most of the work you will do in this project however, will be in  src/SaturnSample , which looks like the following when expanded:  \u251c\u2500\u2500 bin\n\u251c\u2500\u2500 Books\n|   \u251c\u2500\u2500 BooksController.fs\n|   \u251c\u2500\u2500 BooksModel.fs\n|   \u251c\u2500\u2500 BooksRepository.fs\n|   \u2514\u2500\u2500 BooksView.fs\n\u251c\u2500\u2500 obj\n\u251c\u2500\u2500 static\n|   \u251c\u2500\u2500 app.css\n|   \u2514\u2500\u2500 app.js\n\u251c\u2500\u2500 Templates\n|   \u251c\u2500\u2500 App.fs\n|   \u251c\u2500\u2500 Index.fs\n|   \u251c\u2500\u2500 InternalError.fs\n|   \u2514\u2500\u2500 NotFound.fs\n\u251c\u2500\u2500 Config.fs\n\u251c\u2500\u2500 Database.fs\n\u251c\u2500\u2500 database.sqlite\n\u251c\u2500\u2500 paket.references\n\u251c\u2500\u2500 Program.fs\n\u251c\u2500\u2500 Router.fs\n\u2514\u2500\u2500 SaturnSample.fsproj  bin  and  obj  folders store the compiled version of the program after you build the project.  The convention for Saturn is that the model and everything associated with it are inside one folder. Everything is also named with the plural form of the model so \"Books\" instead of \"Book\".  Your static files like css, js, and images should be inside the  static  folder.  Config.fs  contains a  Config  record that stores settings that you can use inside your application. By default, the record only contains the  connectionString  field.  Database.fs  contains functions to execute SQL queries within the program through  Dapper .  If you did not run  dotnet saturn migration  as in the  how to start guide , you might not see  database.sqlite , but that is the database file that your Saturn project is using to store data.  paket.references  shows the packages that your project is using.  Program.fs  handles intializing the program and loading up various settings.  Router.fs  is where you will set the route of the site and what page to load.  Lastly,  SaturnSample.fsproj  is the project file itself.",
            "title": "Directory Structure"
        },
        {
            "location": "/guides/adding-pages/",
            "text": "Adding Pages\n\n\nThis guide uses the same project from the \nhow to start guide\n. Let's add two pages to it. One hello page and a page that can get your name from the URL.\n\n\nCreating the View\n\n\nTo begin, create a \nHello\n folder inside the \nsrc/SaturnSample\n folder.\n\n\nInside the folder, create a new file called \"HelloViews.fs\". This file will contain the functions to create the page.\n\n\nInsert the following into the file:\n\n\nnamespace Hello\n\nopen Giraffe.GiraffeViewEngine\nopen Saturn\n\nmodule Views =\n  let index =\n    div [] [\n        h2 [] [rawText \"Hello from Saturn!\"]\n    ]\n\n\n\n\nOne of the dependencies required is \nGiraffe View Engine\n. This will allow your project to define HTML within your function. The \nindex\n function will result in the following HTML code:\n\n\n<div>\n    <h2>Hello from Saturn!</h2>\n</div>\n\n\n\n\nCreating the Controller\n\n\nCreate a \nHelloController.fs\n file inside the \nHello\n folder.\n\n\nThe \nindex\n function tells us what the HTML will be but we still need to tell Saturn to return it as an HTML page. We also need to tell Saturn where the page is.\n\n\nInsert the following into the file:\n\n\nnamespace Hello\n\nopen Saturn\nopen Giraffe.ResponseWriters\n\nmodule Controller =\n    let indexAction =\n        htmlView (Views.index)\n\n    let helloView = router {\n        get \"/\" indexAction\n    }\n\n\n\n\nThe \nindexAction\n tells Saturn to create an HTML page using the \nindex\n function inside \"HelloViews.fs\"\n\n\nhelloView\n lets Saturn know that the page is located at the root.\n\n\nAdding the 2 new files to the project\n\n\nFor the project to see the new files, modify SaturnSample.fsproj as below:\n\n\n<ItemGroup>\n    <Compile Include=\"Database.fs\" />\n    <Compile Include=\"Config.fs\" />\n\n    <Compile Include=\"Hello\\HelloViews.fs\" />\n    <Compile Include=\"Hello\\HelloController.fs\" />\n    ...\n\n\n\n\nAdding it to Router.fs\n\n\nAfter setting up the route, you need to update the project with the new route.\n\n\nIn \"Router.fs\", add the following to the inside of the \nbrowserRouter\n function:\n\n\nforward \"/hello\" Hello.Controller.helloView\n\n\n\n\nThis means that when we navigate to \nhttp://localhost:8085/hello\n, the \nhelloView\n function will determine what page to load there. Looking inside the \nhelloView\n function, we said that \nindexAction\n is called at the root. In conclusion, the page will be located at \nhttp://localhost:8085/hello/\n. (Note the \"/\" at the end)\n\n\nNow run the program and go to \nhttp://localhost:8085/hello/\n and you will see a page saying \"Hello from Saturn!\"\n\n\nSending a parameter to your page\n\n\nWhat if you want the page to display your name?\n\n\nOne way to retrieve your name is to get it from the route. So when you go to \nhttp://localhost:8085/hello/{yourname}\n with {yourname} being your actual name, it will grab your name which can then be used to display on the page.\n\n\nTo begin, add a new view in your \nHelloViews.fs\n:\n\n\n  let index2 (name : string) =\n    div [] [\n        h2 [] [rawText (\"Hello \" + name + \"!\")]\n    ]\n\n\n\n\nThis function requires passing in the name to be displayed. The name will be retrieved from the route.\n\n\nAdd the following to the \nHelloController.fs\n file below the \nhelloView\n handler:\n\n\nlet index2Action name=\n    htmlView (Hello.Views.index2 name)\n\n\n\n\nNow to set up the route. Add the following to the \nHelloView\n handler:\n\n\ngetf \"/%s\" index2Action\n\n\n\n\n\"%s\" is a format string. This lets Saturn know to save whatever you type in that spot. Since we want to save a name, we want to save it as a string so we use \n%s\n.\n\n\nThere are other format strings for different types:\n\n\n\n\n\n\n\n\nFormat String\n\n\nType\n\n\n\n\n\n\n\n\n\n\n%b\n\n\nbool\n\n\n\n\n\n\n%c\n\n\nchar\n\n\n\n\n\n\n%s\n\n\nstring\n\n\n\n\n\n\n%i\n\n\nint\n\n\n\n\n\n\n%d\n\n\nint64\n\n\n\n\n\n\n%f\n\n\nfloat\n/\ndouble\n\n\n\n\n\n\n%O\n\n\nGuid\n\n\n\n\n\n\n\n\nNow run the program and go to \nhttp://localhost:8085/hello/{yourname}\n and replace \n{yourname}\n with your name to see a page that will greet you.",
            "title": "Adding Pages"
        },
        {
            "location": "/guides/adding-pages/#adding-pages",
            "text": "This guide uses the same project from the  how to start guide . Let's add two pages to it. One hello page and a page that can get your name from the URL.",
            "title": "Adding Pages"
        },
        {
            "location": "/guides/adding-pages/#creating-the-view",
            "text": "To begin, create a  Hello  folder inside the  src/SaturnSample  folder.  Inside the folder, create a new file called \"HelloViews.fs\". This file will contain the functions to create the page.  Insert the following into the file:  namespace Hello\n\nopen Giraffe.GiraffeViewEngine\nopen Saturn\n\nmodule Views =\n  let index =\n    div [] [\n        h2 [] [rawText \"Hello from Saturn!\"]\n    ]  One of the dependencies required is  Giraffe View Engine . This will allow your project to define HTML within your function. The  index  function will result in the following HTML code:  <div>\n    <h2>Hello from Saturn!</h2>\n</div>",
            "title": "Creating the View"
        },
        {
            "location": "/guides/adding-pages/#creating-the-controller",
            "text": "Create a  HelloController.fs  file inside the  Hello  folder.  The  index  function tells us what the HTML will be but we still need to tell Saturn to return it as an HTML page. We also need to tell Saturn where the page is.  Insert the following into the file:  namespace Hello\n\nopen Saturn\nopen Giraffe.ResponseWriters\n\nmodule Controller =\n    let indexAction =\n        htmlView (Views.index)\n\n    let helloView = router {\n        get \"/\" indexAction\n    }  The  indexAction  tells Saturn to create an HTML page using the  index  function inside \"HelloViews.fs\"  helloView  lets Saturn know that the page is located at the root.",
            "title": "Creating the Controller"
        },
        {
            "location": "/guides/adding-pages/#adding-the-2-new-files-to-the-project",
            "text": "For the project to see the new files, modify SaturnSample.fsproj as below:  <ItemGroup>\n    <Compile Include=\"Database.fs\" />\n    <Compile Include=\"Config.fs\" />\n\n    <Compile Include=\"Hello\\HelloViews.fs\" />\n    <Compile Include=\"Hello\\HelloController.fs\" />\n    ...",
            "title": "Adding the 2 new files to the project"
        },
        {
            "location": "/guides/adding-pages/#adding-it-to-routerfs",
            "text": "After setting up the route, you need to update the project with the new route.  In \"Router.fs\", add the following to the inside of the  browserRouter  function:  forward \"/hello\" Hello.Controller.helloView  This means that when we navigate to  http://localhost:8085/hello , the  helloView  function will determine what page to load there. Looking inside the  helloView  function, we said that  indexAction  is called at the root. In conclusion, the page will be located at  http://localhost:8085/hello/ . (Note the \"/\" at the end)  Now run the program and go to  http://localhost:8085/hello/  and you will see a page saying \"Hello from Saturn!\"",
            "title": "Adding it to Router.fs"
        },
        {
            "location": "/guides/adding-pages/#sending-a-parameter-to-your-page",
            "text": "What if you want the page to display your name?  One way to retrieve your name is to get it from the route. So when you go to  http://localhost:8085/hello/{yourname}  with {yourname} being your actual name, it will grab your name which can then be used to display on the page.  To begin, add a new view in your  HelloViews.fs :    let index2 (name : string) =\n    div [] [\n        h2 [] [rawText (\"Hello \" + name + \"!\")]\n    ]  This function requires passing in the name to be displayed. The name will be retrieved from the route.  Add the following to the  HelloController.fs  file below the  helloView  handler:  let index2Action name=\n    htmlView (Hello.Views.index2 name)  Now to set up the route. Add the following to the  HelloView  handler:  getf \"/%s\" index2Action  \"%s\" is a format string. This lets Saturn know to save whatever you type in that spot. Since we want to save a name, we want to save it as a string so we use  %s .  There are other format strings for different types:     Format String  Type      %b  bool    %c  char    %s  string    %i  int    %d  int64    %f  float / double    %O  Guid     Now run the program and go to  http://localhost:8085/hello/{yourname}  and replace  {yourname}  with your name to see a page that will greet you.",
            "title": "Sending a parameter to your page"
        },
        {
            "location": "/guides/routing/",
            "text": "Routing\n\n\nRoutes are how Saturn connects all the HTTP requests to the different actions. Think of a route as the URL of the application. The site is yoursite.com but you may have a route for your about page such as yoursite.com/about.\n\n\nIn Saturn, \nRouters\n contain all the routes of your application. A router is a list of routes. A website can have a router that handles the different routes to your page like so:\n\n\nyoursite.com\n    \u251c\u2500\u2500 \"/\"             -yoursite.com/\n    \u251c\u2500\u2500 \"/about\"        -yoursite.com/about\n    \u251c\u2500\u2500 \"/contact\"      -yoursite.com/contact\n    \u251c\u2500\u2500 \"/news\"         -yoursite.com/news\n    \u2514\u2500\u2500 \"/investors\"    -yoursite.com/investors\n\n\n\nSince this is at the root, this is your router at \n\"\"\n path. You can then add a router inside another router to have the following:\n\n\nyoursite.com\n    \u251c\u2500\u2500 books           -yoursite.com/books\n    |   \u251c\u2500\u2500 list        -yoursite.com/books/list\n    |   \u251c\u2500\u2500 add         -yoursite.com/books/add\n    |   \u251c\u2500\u2500 update      -yoursite.com/books/update\n    |   \u2514\u2500\u2500 delete      -yoursite.com/books/update\n    \u251c\u2500\u2500 about           -yoursite.com/about\n    \u251c\u2500\u2500 contact         -yoursite.com/contact\n    \u251c\u2500\u2500 news            -yoursite.com/news\n    \u2514\u2500\u2500 investors       -yoursite.com/investors\n\n\n\nNow you have a router for the \n\"/books\"\n path inside another router for the \n\"\"\n path.\n\n\nNow to see it in code, create a Saturn project from the template and you will have a \nRouter.fs\n file like this:\n\n\nmodule Router\n\nopen Saturn\nopen Giraffe.Core\nopen Giraffe.ResponseWriters\n\n\nlet browser = pipeline {\n    plug acceptHtml\n    plug putSecureBrowserHeaders\n    plug fetchSession\n    set_header \"x-pipeline-type\" \"Browser\"\n}\n\nlet defaultView = router {\n    get \"/\" (htmlView Index.layout)\n    get \"/index.html\" (redirectTo false \"/\")\n    get \"/default.html\" (redirectTo false \"/\")\n}\n\nlet browserRouter = router {\n    not_found_handler (htmlView NotFound.layout) //Use the default 404 webpage\n    pipe_through browser //Use the default browser pipeline\n\n    forward \"\" defaultView //Use the default view\n}\n\n//Other scopes may use different pipelines and error handlers\n\n// let api = pipeline {\n//     plug acceptJson\n//     set_header \"x-pipeline-type\" \"Api\"\n// }\n\n// let apiRouter = router {\n//     not_found_handler (setStatusCode 404 >=> text \"Api 404\")\n//     pipe_through api\n//\n//     forward \"/someApi\" someScopeOrController\n// }\n\nlet appRouter = router {\n    // forward \"/api\" apiRouter\n    forward \"\" browserRouter\n}\n\n\n\n\nFirst, take a look at the \nrouter\n function.\n\n\nlet appRouter = router {\n    forward \"\" browserRouter\n}\n\n\n\n\nThe \nappRouter\n value is a \nrouter\n. Inside is the \nforward \"\" browserRouter\n line. The \nforward\n function needs a path and a router. In this case, the path is an empty string and the router is \nbrowserRouter\n. That means that the \nbrowserRouter\n router will handle the routes at the current location. Since \nappRouter\n is the first router called, the current location is the root of the application.\n\n\nNow let's look at \nbrowserRouter\n:\n\n\nlet browserRouter = router {\n    not_found_handler (htmlView NotFound.layout)\n    pipe_through browser\n\n    forward \"\" defaultView\n}\n\n\n\n\nThere are three lines. The first line, \nnot_found_handler (htmlView NotFound.layout)\n tells \nbrowserRouter\n to display a not found page if the user enters a route that the application does not handle. The second line tells the application to use the \nbrowser\n pipeline defined above. The pipeline is a list of settings on how the website will deliver the pages. Lastly, \nforward \"\" defaultView\n is like \nforward \"\" browserRouter\n from the \nappRouter\n. Again, \nbrowserRouter\n does not contain any routes but it tells the \ndefaultView\n router to handle them. Finally, we get to the part where the application is told how to handle the routes. Inside \ndefaultView\n, we created 3 routes:\n\n\nlet defaultView = router {\n    get \"/\" (htmlView Index.layout)\n    get \"/index.html\" (redirectTo false \"/\")\n    get \"/default.html\" (redirectTo false \"/\")\n}\n\n\n\n\nHere, we see that \nget\n is used to define the routes. There are 3 routes here but 2 of them redirect to the first route. To illustrate, the routes are:\n\n\nyoursite.com\n    \u2514\u2500\u2500 \"\" (router)\n        \u2514\u2500\u2500 \"\" (browserRouter)\n            \u2514\u2500\u2500 \"\" (defaultView)\n                \u251c\u2500\u2500 \"/\"                 -yoursite.com/\n                \u251c\u2500\u2500 \"/index.html\"       -redirect to yoursite.com/\n                \u2514\u2500\u2500 \"/default.html\"     -redirect to yoursite.com/\n\n\n\nLooking at the first line inside \ndefaultView\n, \nget \"/\" (htmlView Index.layout)\n tells the application to display \nIndex.layout\n at the root of the application. The \nget\n corresponds to the HTTP verb GET so when you type in a link, the browser tries to GET the page. The first parameter of \nget\n is \"/\", so basically when getting the root, the \nget\n function will return something. The second parameter is \n(htmlView Index.layout)\n so the \nget\n function returns an HTML page specified by Index.layout. The second and third line have \n(redirectTo false \"/\")\n, telling the application to go to \"yoursite.com/\" when going to \"yoursite.com/index\" or \"yoursite.com/default\"\n\n\nBest Practices\n\n\nYou can combine all 3 routers into one router like so:\n\n\nlet appRouter = router {\n    not_found_handler (htmlView NotFound.layout)\n    pipe_through browser\n\n    get \"/\" (htmlView Index.layout)\n    get \"/index.html\" (redirectTo false \"/\")\n    get \"/default.html\" (redirectTo false \"/\")\n}\n\n\n\n\nThe template splits them into 3 to encourage good practices. In the first router, you can see the commented out code \nforward \"/api\" apiRouter\n. This is a good suggestion in the template to have a separate router to handle your API routes. We set up how to deliever the webpage with \npipe_through browser\n in \nbrowserRouter\n. The settings are important for a browser to know how to handle your routes but not for a different application to access your routes as an API.\n\n\nThe template provides an example of how to set up the API routes in the commented out code, which I copied below:\n\n\nlet api = pipeline {\n    plug acceptJson\n    set_header \"x-pipeline-type\" \"Api\"\n}\n\nlet apiRouter = router {\n    not_found_handler (setStatusCode 404 >=> text \"Api 404\")\n    pipe_through api\n\n    forward \"/someApi\" someScopeOrController\n}\n\n\n\n\n\nHere we have the \napiRouter\n router which does not return a 404 page but a 404 text instead which is appropriate for an API. The router also uses a pipeline that is more appropriate for an API such as accepting JSON inputs instead of HTML as in the \nbrowser\n pipeline.\n\n\nFormat Strings\n\n\nYou might be wondering how to make routes that accept a numerical ID. You can make multiple routes for each ID like so\n\n\nget \"/1\" (getApplication 1)\nget \"/2\" (getApplication 2)\nget \"/3\" (getApplication 3)\n...\n\n\n\nBut this is impracticle because there can be a large number of items or new items are constantly being created with new IDs. Instead the solution is to use format strings. Remember that in the \nAdding Pages Guide\n, we used \ngetf \"/%s\" index2Action\n to pass a string to page.\n\n\n\n\n\n\n\n\nFormat Char\n\n\nType\n\n\n\n\n\n\n\n\n\n\n%b\n\n\nbool\n\n\n\n\n\n\n%c\n\n\nchar\n\n\n\n\n\n\n%s\n\n\nstring\n\n\n\n\n\n\n%i\n\n\nint\n\n\n\n\n\n\n%d\n\n\nint64\n\n\n\n\n\n\n%f\n\n\nfloat\n/\ndouble\n\n\n\n\n\n\n%O\n\n\nGuid\n\n\n\n\n\n\n\n\nFor a numerical ID, we want to pass an int which is \n%i\n in the list above, so you can replace the lines above with\n\n\ngetf \"/%i\" getApplication\n\n\n\n\nNotice that \ngetf\n is used instead of get. This is a separate version of get that handles \nf\normat characters.\n\n\nYou can use format strings with \"forward\" too by using \"forwardf\"\n\n\n\nThere are a lot of functionalities within routers and you can view all of them \nhere\n.",
            "title": "Routing"
        },
        {
            "location": "/guides/routing/#routing",
            "text": "Routes are how Saturn connects all the HTTP requests to the different actions. Think of a route as the URL of the application. The site is yoursite.com but you may have a route for your about page such as yoursite.com/about.  In Saturn,  Routers  contain all the routes of your application. A router is a list of routes. A website can have a router that handles the different routes to your page like so:  yoursite.com\n    \u251c\u2500\u2500 \"/\"             -yoursite.com/\n    \u251c\u2500\u2500 \"/about\"        -yoursite.com/about\n    \u251c\u2500\u2500 \"/contact\"      -yoursite.com/contact\n    \u251c\u2500\u2500 \"/news\"         -yoursite.com/news\n    \u2514\u2500\u2500 \"/investors\"    -yoursite.com/investors  Since this is at the root, this is your router at  \"\"  path. You can then add a router inside another router to have the following:  yoursite.com\n    \u251c\u2500\u2500 books           -yoursite.com/books\n    |   \u251c\u2500\u2500 list        -yoursite.com/books/list\n    |   \u251c\u2500\u2500 add         -yoursite.com/books/add\n    |   \u251c\u2500\u2500 update      -yoursite.com/books/update\n    |   \u2514\u2500\u2500 delete      -yoursite.com/books/update\n    \u251c\u2500\u2500 about           -yoursite.com/about\n    \u251c\u2500\u2500 contact         -yoursite.com/contact\n    \u251c\u2500\u2500 news            -yoursite.com/news\n    \u2514\u2500\u2500 investors       -yoursite.com/investors  Now you have a router for the  \"/books\"  path inside another router for the  \"\"  path.  Now to see it in code, create a Saturn project from the template and you will have a  Router.fs  file like this:  module Router\n\nopen Saturn\nopen Giraffe.Core\nopen Giraffe.ResponseWriters\n\n\nlet browser = pipeline {\n    plug acceptHtml\n    plug putSecureBrowserHeaders\n    plug fetchSession\n    set_header \"x-pipeline-type\" \"Browser\"\n}\n\nlet defaultView = router {\n    get \"/\" (htmlView Index.layout)\n    get \"/index.html\" (redirectTo false \"/\")\n    get \"/default.html\" (redirectTo false \"/\")\n}\n\nlet browserRouter = router {\n    not_found_handler (htmlView NotFound.layout) //Use the default 404 webpage\n    pipe_through browser //Use the default browser pipeline\n\n    forward \"\" defaultView //Use the default view\n}\n\n//Other scopes may use different pipelines and error handlers\n\n// let api = pipeline {\n//     plug acceptJson\n//     set_header \"x-pipeline-type\" \"Api\"\n// }\n\n// let apiRouter = router {\n//     not_found_handler (setStatusCode 404 >=> text \"Api 404\")\n//     pipe_through api\n//\n//     forward \"/someApi\" someScopeOrController\n// }\n\nlet appRouter = router {\n    // forward \"/api\" apiRouter\n    forward \"\" browserRouter\n}  First, take a look at the  router  function.  let appRouter = router {\n    forward \"\" browserRouter\n}  The  appRouter  value is a  router . Inside is the  forward \"\" browserRouter  line. The  forward  function needs a path and a router. In this case, the path is an empty string and the router is  browserRouter . That means that the  browserRouter  router will handle the routes at the current location. Since  appRouter  is the first router called, the current location is the root of the application.  Now let's look at  browserRouter :  let browserRouter = router {\n    not_found_handler (htmlView NotFound.layout)\n    pipe_through browser\n\n    forward \"\" defaultView\n}  There are three lines. The first line,  not_found_handler (htmlView NotFound.layout)  tells  browserRouter  to display a not found page if the user enters a route that the application does not handle. The second line tells the application to use the  browser  pipeline defined above. The pipeline is a list of settings on how the website will deliver the pages. Lastly,  forward \"\" defaultView  is like  forward \"\" browserRouter  from the  appRouter . Again,  browserRouter  does not contain any routes but it tells the  defaultView  router to handle them. Finally, we get to the part where the application is told how to handle the routes. Inside  defaultView , we created 3 routes:  let defaultView = router {\n    get \"/\" (htmlView Index.layout)\n    get \"/index.html\" (redirectTo false \"/\")\n    get \"/default.html\" (redirectTo false \"/\")\n}  Here, we see that  get  is used to define the routes. There are 3 routes here but 2 of them redirect to the first route. To illustrate, the routes are:  yoursite.com\n    \u2514\u2500\u2500 \"\" (router)\n        \u2514\u2500\u2500 \"\" (browserRouter)\n            \u2514\u2500\u2500 \"\" (defaultView)\n                \u251c\u2500\u2500 \"/\"                 -yoursite.com/\n                \u251c\u2500\u2500 \"/index.html\"       -redirect to yoursite.com/\n                \u2514\u2500\u2500 \"/default.html\"     -redirect to yoursite.com/  Looking at the first line inside  defaultView ,  get \"/\" (htmlView Index.layout)  tells the application to display  Index.layout  at the root of the application. The  get  corresponds to the HTTP verb GET so when you type in a link, the browser tries to GET the page. The first parameter of  get  is \"/\", so basically when getting the root, the  get  function will return something. The second parameter is  (htmlView Index.layout)  so the  get  function returns an HTML page specified by Index.layout. The second and third line have  (redirectTo false \"/\") , telling the application to go to \"yoursite.com/\" when going to \"yoursite.com/index\" or \"yoursite.com/default\"",
            "title": "Routing"
        },
        {
            "location": "/guides/routing/#best-practices",
            "text": "You can combine all 3 routers into one router like so:  let appRouter = router {\n    not_found_handler (htmlView NotFound.layout)\n    pipe_through browser\n\n    get \"/\" (htmlView Index.layout)\n    get \"/index.html\" (redirectTo false \"/\")\n    get \"/default.html\" (redirectTo false \"/\")\n}  The template splits them into 3 to encourage good practices. In the first router, you can see the commented out code  forward \"/api\" apiRouter . This is a good suggestion in the template to have a separate router to handle your API routes. We set up how to deliever the webpage with  pipe_through browser  in  browserRouter . The settings are important for a browser to know how to handle your routes but not for a different application to access your routes as an API.  The template provides an example of how to set up the API routes in the commented out code, which I copied below:  let api = pipeline {\n    plug acceptJson\n    set_header \"x-pipeline-type\" \"Api\"\n}\n\nlet apiRouter = router {\n    not_found_handler (setStatusCode 404 >=> text \"Api 404\")\n    pipe_through api\n\n    forward \"/someApi\" someScopeOrController\n}  Here we have the  apiRouter  router which does not return a 404 page but a 404 text instead which is appropriate for an API. The router also uses a pipeline that is more appropriate for an API such as accepting JSON inputs instead of HTML as in the  browser  pipeline.",
            "title": "Best Practices"
        },
        {
            "location": "/guides/routing/#format-strings",
            "text": "You might be wondering how to make routes that accept a numerical ID. You can make multiple routes for each ID like so  get \"/1\" (getApplication 1)\nget \"/2\" (getApplication 2)\nget \"/3\" (getApplication 3)\n...  But this is impracticle because there can be a large number of items or new items are constantly being created with new IDs. Instead the solution is to use format strings. Remember that in the  Adding Pages Guide , we used  getf \"/%s\" index2Action  to pass a string to page.     Format Char  Type      %b  bool    %c  char    %s  string    %i  int    %d  int64    %f  float / double    %O  Guid     For a numerical ID, we want to pass an int which is  %i  in the list above, so you can replace the lines above with  getf \"/%i\" getApplication  Notice that  getf  is used instead of get. This is a separate version of get that handles  f ormat characters.  You can use format strings with \"forward\" too by using \"forwardf\"  There are a lot of functionalities within routers and you can view all of them  here .",
            "title": "Format Strings"
        },
        {
            "location": "/guides/controller/",
            "text": "Controller\n\n\nIn Saturn, a \ncontroller\n is a list of routes that is focused on a \nmodel\n (an object that contains your data). So if you have a user model, some common operations are to display the list of users, show details of a user, add a user, update or user, or remove a user. A controller is a great way to organize all of these actions.\n\n\nEach of the operations is a separate route and a controller is an easy way to group these routes together.\n\n\nA basic user controller is shown below:\n\n\nlet userController = controller {\n    index (fun ctx -> \"Index handler version 1\" |> Controller.text ctx) //View list of users\n    add (fun ctx -> \"Add handler version 1\" |> Controller.text ctx) //Add a user\n    create (fun ctx -> \"Create handler version 1\" |> Controller.text ctx) //Create a user\n    show (fun ctx id -> (sprintf \"Show handler version 1 - %i\" id) |> Controller.text ctx) //Show details of a user\n    edit (fun ctx id -> (sprintf \"Edit handler version 1 - %i\" id) |> Controller.text ctx)  //Edit a user\n    update (fun ctx id -> (sprintf \"Update handler version 1 - %i\" id) |> Controller.text ctx)  //Update a user\n}\n\n\n\n\nHere we can see the \nindex\n, \nadd\n, \ncreate\n, \nshow\n, \nedit\n, and \nupdate\n operations but there are more operations that are not shown here like \npatch\n and \ndelete\n. You can see all the operations \nhere\n. You do not have to handle all of the operations.\n\n\nYou might be wondering what the difference is between \nadd\n and \ncreate\n or \nedit\n and \nupdate\n. The \nadd\n operation tells the application to return the form so that the user can enter the data for the user to be added. The \ncreate\n operation will commit the data to the database of the application. It is the same with \nedit\n for displaying the form and \nupdate\n for committing the change.\n\n\nTo add the controller for the routes, you can add it to the \ndefaultView\n router like so:\n\n\nlet defaultView = router {\n    get \"/\" (htmlView Index.layout)\n    get \"/index.html\" (redirectTo false \"/\")\n    get \"/default.html\" (redirectTo false \"/\")\n    forward \"/users\" userController\n}\n\n\n\n\nThe route will now be:\n\n\nyoursite.com\n    \u2514\u2500\u2500 \"\" (router)\n        \u2514\u2500\u2500 \"\" (browserRouter)\n            \u2514\u2500\u2500 \"\" (defaultView)\n                \u251c\u2500\u2500 \"/\"                 -yoursite.com/\n                \u251c\u2500\u2500 \"/index.html\"       -redirect to yoursite.com/\n                \u251c\u2500\u2500 \"/default.html\"     -redirect to yoursite.com/\n                \u2514\u2500\u2500 \"/users\"\n                    \u251c\u2500\u2500 index \"/\"           -yoursite.com/users/\n                    \u251c\u2500\u2500 add \"/add\"          -yoursite.com/users/add\n                    \u251c\u2500\u2500 create              -POST yoursite.com/users/add\n                    \u251c\u2500\u2500 show \"/%i\"          -yoursite.com/users/%i\n                    \u251c\u2500\u2500 edit \"/%i/edit\"     -yoursite.com/users/%i/edit\n                    \u2514\u2500\u2500 update \"\"           -POST yoursite.com/users/%i/edit\n\n\n\nThe create and update operations make changes to the database so you have to make a POST request containing the information you want to save to the database.\n\n\nSubcontroller\n\n\nNow that you know how to chain routers together to create routes, we can look at a common scenario for a website. A website usually has users and each user can create multiple comments.\n\n\nyoursite.com\n    \u2514\u2500\u2500 \"/users\"\n        \u2514\u2500\u2500 \"/%i\"           -yoursite.com/users/%i\n            \u2514\u2500\u2500 \"/comments\" (commentController)\n                \u251c\u2500\u2500 index \"/\"           -yoursite.com/users/{userId}/comments/\n                \u2514\u2500\u2500 show \"/%i\"          -yoursite.com/users/{userId}/comments/{commentId}\n\n\n\nIn Saturn, you can make the comment controller a subcontroller of the user controller. It looks like the following code:\n\n\nlet commentController userId = controller {\n    index (fun ctx -> (sprintf \"Comment Index handler for user %i\" userId ) |> Controller.text ctx)\n    add (fun ctx -> (sprintf \"Comment Add handler for user %i\" userId ) |> Controller.text ctx)\n    show (fun ctx id -> (sprintf \"Show comment %s handler for user %i\" id userId ) |> Controller.text ctx)\n    edit (fun ctx id -> (sprintf \"Edit comment %s handler for user %i\" id userId )  |> Controller.text ctx)\n}\n\nlet userController = controller {\n    subController \"/comments\" commentController\n\n    plug [All] (setHttpHeader \"user-controller-common\" \"123\")\n    plug [Index; Show] (setHttpHeader \"user-controller-specialized\" \"123\")\n\n    index (fun ctx -> \"Index handler no version\" |> Controller.text ctx)\n    show (fun ctx id -> (sprintf \"Show handler no version - %i\" id) |> Controller.text ctx)\n    add (fun ctx -> \"Add handler no version\" |> Controller.text ctx)\n    create (fun ctx -> \"Create handler no version\" |> Controller.text ctx)\n    edit (fun ctx id -> (sprintf \"Edit handler no version - %i\" id) |> Controller.text ctx)\n    update (fun ctx id -> (sprintf \"Update handler no version - %i\" id) |> Controller.text ctx)\n    delete (fun ctx id -> failwith (sprintf \"Delete handler no version failed - %i\" id) |> Controller.text ctx)\n    error_handler (fun ctx ex -> sprintf \"Error handler no version - %s\" ex.Message |> Controller.text ctx)\n}\n\n\n\n\nTo create a subcontroller, start with creating a controller for your model. After that, define it as a subcontrolller inside the main controller with the following code:\n\n\n    subController \"/yourModel\" yourModelController",
            "title": "Controller"
        },
        {
            "location": "/guides/controller/#controller",
            "text": "In Saturn, a  controller  is a list of routes that is focused on a  model  (an object that contains your data). So if you have a user model, some common operations are to display the list of users, show details of a user, add a user, update or user, or remove a user. A controller is a great way to organize all of these actions.  Each of the operations is a separate route and a controller is an easy way to group these routes together.  A basic user controller is shown below:  let userController = controller {\n    index (fun ctx -> \"Index handler version 1\" |> Controller.text ctx) //View list of users\n    add (fun ctx -> \"Add handler version 1\" |> Controller.text ctx) //Add a user\n    create (fun ctx -> \"Create handler version 1\" |> Controller.text ctx) //Create a user\n    show (fun ctx id -> (sprintf \"Show handler version 1 - %i\" id) |> Controller.text ctx) //Show details of a user\n    edit (fun ctx id -> (sprintf \"Edit handler version 1 - %i\" id) |> Controller.text ctx)  //Edit a user\n    update (fun ctx id -> (sprintf \"Update handler version 1 - %i\" id) |> Controller.text ctx)  //Update a user\n}  Here we can see the  index ,  add ,  create ,  show ,  edit , and  update  operations but there are more operations that are not shown here like  patch  and  delete . You can see all the operations  here . You do not have to handle all of the operations.  You might be wondering what the difference is between  add  and  create  or  edit  and  update . The  add  operation tells the application to return the form so that the user can enter the data for the user to be added. The  create  operation will commit the data to the database of the application. It is the same with  edit  for displaying the form and  update  for committing the change.  To add the controller for the routes, you can add it to the  defaultView  router like so:  let defaultView = router {\n    get \"/\" (htmlView Index.layout)\n    get \"/index.html\" (redirectTo false \"/\")\n    get \"/default.html\" (redirectTo false \"/\")\n    forward \"/users\" userController\n}  The route will now be:  yoursite.com\n    \u2514\u2500\u2500 \"\" (router)\n        \u2514\u2500\u2500 \"\" (browserRouter)\n            \u2514\u2500\u2500 \"\" (defaultView)\n                \u251c\u2500\u2500 \"/\"                 -yoursite.com/\n                \u251c\u2500\u2500 \"/index.html\"       -redirect to yoursite.com/\n                \u251c\u2500\u2500 \"/default.html\"     -redirect to yoursite.com/\n                \u2514\u2500\u2500 \"/users\"\n                    \u251c\u2500\u2500 index \"/\"           -yoursite.com/users/\n                    \u251c\u2500\u2500 add \"/add\"          -yoursite.com/users/add\n                    \u251c\u2500\u2500 create              -POST yoursite.com/users/add\n                    \u251c\u2500\u2500 show \"/%i\"          -yoursite.com/users/%i\n                    \u251c\u2500\u2500 edit \"/%i/edit\"     -yoursite.com/users/%i/edit\n                    \u2514\u2500\u2500 update \"\"           -POST yoursite.com/users/%i/edit  The create and update operations make changes to the database so you have to make a POST request containing the information you want to save to the database.",
            "title": "Controller"
        },
        {
            "location": "/guides/controller/#subcontroller",
            "text": "Now that you know how to chain routers together to create routes, we can look at a common scenario for a website. A website usually has users and each user can create multiple comments.  yoursite.com\n    \u2514\u2500\u2500 \"/users\"\n        \u2514\u2500\u2500 \"/%i\"           -yoursite.com/users/%i\n            \u2514\u2500\u2500 \"/comments\" (commentController)\n                \u251c\u2500\u2500 index \"/\"           -yoursite.com/users/{userId}/comments/\n                \u2514\u2500\u2500 show \"/%i\"          -yoursite.com/users/{userId}/comments/{commentId}  In Saturn, you can make the comment controller a subcontroller of the user controller. It looks like the following code:  let commentController userId = controller {\n    index (fun ctx -> (sprintf \"Comment Index handler for user %i\" userId ) |> Controller.text ctx)\n    add (fun ctx -> (sprintf \"Comment Add handler for user %i\" userId ) |> Controller.text ctx)\n    show (fun ctx id -> (sprintf \"Show comment %s handler for user %i\" id userId ) |> Controller.text ctx)\n    edit (fun ctx id -> (sprintf \"Edit comment %s handler for user %i\" id userId )  |> Controller.text ctx)\n}\n\nlet userController = controller {\n    subController \"/comments\" commentController\n\n    plug [All] (setHttpHeader \"user-controller-common\" \"123\")\n    plug [Index; Show] (setHttpHeader \"user-controller-specialized\" \"123\")\n\n    index (fun ctx -> \"Index handler no version\" |> Controller.text ctx)\n    show (fun ctx id -> (sprintf \"Show handler no version - %i\" id) |> Controller.text ctx)\n    add (fun ctx -> \"Add handler no version\" |> Controller.text ctx)\n    create (fun ctx -> \"Create handler no version\" |> Controller.text ctx)\n    edit (fun ctx id -> (sprintf \"Edit handler no version - %i\" id) |> Controller.text ctx)\n    update (fun ctx id -> (sprintf \"Update handler no version - %i\" id) |> Controller.text ctx)\n    delete (fun ctx id -> failwith (sprintf \"Delete handler no version failed - %i\" id) |> Controller.text ctx)\n    error_handler (fun ctx ex -> sprintf \"Error handler no version - %s\" ex.Message |> Controller.text ctx)\n}  To create a subcontroller, start with creating a controller for your model. After that, define it as a subcontrolller inside the main controller with the following code:      subController \"/yourModel\" yourModelController",
            "title": "Subcontroller"
        },
        {
            "location": "/guides/scaffolding/",
            "text": "Scaffolding\n\n\nSaturn provides a command line scaffolding tool to generate a model, database migration, controller, and associated views.\n\n\nTo use the generator, run the \ndotnet saturn\n command from the subdirectory in the server application.  If you have used the template to generate your project, this is the \nsrc\\<yourprojectname>\n directory.  \n\n\nThere are three flavors of generators that provide flexibility about what types of code is generated to support your model.\n\n\n\n\n\n\n\n\nCommand\n\n\nGenerates\n\n\n\n\n\n\n\n\n\n\ngen\n\n\nCreates a model, database layer, HTML views, and a controller.\n\n\n\n\n\n\ngen.json\n\n\nCreates a model, database layer, and an API controller to access the model.\n\n\n\n\n\n\ngen.model\n\n\nCreates only the model and database layer (no controller or views)\n\n\n\n\n\n\n\n\nEach of these commands will generate a migration for your model as well as a folder containing generated files.\n\n\nFor example:\n\n\ndotnet saturn gen Book Books id:string title:string\n\n\nGenerates the following structure:\n\n\nsrc\n\u251c\u2500\u2500 Migrations\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 201903192143.Book.fs\n\u2502\n\u2514\u2500\u2500 SaturnSample\n    \u2514\u2500\u2500 Books\n     \u00a0\u00a0 \u251c\u2500\u2500 BooksController.fs\n     \u00a0\u00a0 \u251c\u2500\u2500 BooksModel.fs\n     \u00a0\u00a0 \u251c\u2500\u2500 BooksRepository.fs\n     \u00a0\u00a0 \u2514\u2500\u2500 BooksViews.fs\n\n\n\n\nEach of the generators takes arguments in the same format:\n\n\ndotnet saturn gen <SingularModelName> <PluralModelName> <List of model fields with types>\n\n\nThe list of model fields are names and types separated by a colon. \n\n\n<fieldname>:<type>\n\n\nCurrently supported types are:\n\n\n\n\nstring\n\n\nint\n\n\nfloat\n\n\ndouble\n\n\ndecimal\n\n\nguid\n\n\ndatetime\n\n\nbool\n\n\n\n\nMigrations\n\n\nUsing the generator to create a model will also create a migration file that will create a supporting table in the database. Execute the migration script using:\n\n\ndotnet saturn migration",
            "title": "Scaffolding"
        },
        {
            "location": "/guides/scaffolding/#scaffolding",
            "text": "Saturn provides a command line scaffolding tool to generate a model, database migration, controller, and associated views.  To use the generator, run the  dotnet saturn  command from the subdirectory in the server application.  If you have used the template to generate your project, this is the  src\\<yourprojectname>  directory.    There are three flavors of generators that provide flexibility about what types of code is generated to support your model.     Command  Generates      gen  Creates a model, database layer, HTML views, and a controller.    gen.json  Creates a model, database layer, and an API controller to access the model.    gen.model  Creates only the model and database layer (no controller or views)     Each of these commands will generate a migration for your model as well as a folder containing generated files.  For example:  dotnet saturn gen Book Books id:string title:string  Generates the following structure:  src\n\u251c\u2500\u2500 Migrations\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 201903192143.Book.fs\n\u2502\n\u2514\u2500\u2500 SaturnSample\n    \u2514\u2500\u2500 Books\n     \u00a0\u00a0 \u251c\u2500\u2500 BooksController.fs\n     \u00a0\u00a0 \u251c\u2500\u2500 BooksModel.fs\n     \u00a0\u00a0 \u251c\u2500\u2500 BooksRepository.fs\n     \u00a0\u00a0 \u2514\u2500\u2500 BooksViews.fs  Each of the generators takes arguments in the same format:  dotnet saturn gen <SingularModelName> <PluralModelName> <List of model fields with types>  The list of model fields are names and types separated by a colon.   <fieldname>:<type>  Currently supported types are:   string  int  float  double  decimal  guid  datetime  bool",
            "title": "Scaffolding"
        },
        {
            "location": "/guides/scaffolding/#migrations",
            "text": "Using the generator to create a model will also create a migration file that will create a supporting table in the database. Execute the migration script using:  dotnet saturn migration",
            "title": "Migrations"
        },
        {
            "location": "/api/pipeline/",
            "text": "Pipeline\n\n\nPipeline builder\n\n\nComputation expression used to combine \nHttpHandlers\n in a declarative manner.\n\n\nThe result of the computation expression is a standard Giraffe \nHttpHandler\n which means that it's easily composable with other parts of the Giraffe ecosystem.\n\n\nExample:\n\n\nlet headerPipe = pipeline {\n    set_header \"myCustomHeader\" \"abcd\"\n    set_header \"myCustomHeader2\" \"zxcv\"\n}\n\nlet endpointPipe = pipeline {\n    plug fetchSession\n    plug head\n    plug requestId\n}\n\n\n\n\n\n\nplug\n\n\nEnables adding any additional \nHttpHandler\n to the pipeline.\n\n\nInput:\n \nHttpHandler\n\n\nmust_accept\n\n\nFilters a request by the \nAccept\n HTTP header. You can use it to check if a client accepts a certain MIME type before returning a response.\n\n\nInput:\n \nstring\n\n\nchallenge\n\n\nChallenges authentication with a specified authentication scheme.\n\n\nInput:\n \nstring\n\n\nsign_off\n\n\nSigns off the currently logged in user with a specified authentication scheme.\n\n\nInput:\n \nstring\n\n\nrequires_auth_policy\n\n\nValidates if a user satisfies policy requirement, if not the handler will execute the \nauthFailedHandler\n function.\n\n\nInput:\n \n(ClaimsPrincipal -> bool) -> HttpHandler\n\n\nrequires_authentication\n\n\nValidates if a user is authenticated/logged in. If the user is not authenticated then the handler will execute the \nauthFailedHandler\n function.\n\n\nInput:\n \nHttpHandler\n\n\nrequires_role\n\n\nValidates if an authenticated user is in a specified role. If the user fails to be in the required role then the handler will execute the \nauthFailedHandler\n function.\n\n\nInput:\n \nstring -> HttpHandler\n\n\nrequires_role_of\n\n\nValidates if an authenticated user is in one of the supplied roles. If the user fails to be in one of the required roles then the handler will execute the \nauthFailedHandler\n function.\n\n\nInput:\n \nstring list-> HttpHandler\n\n\nclear_response\n\n\nTries to clear the current response. This can be useful inside an error handler to reset the response before writing an error message to the body of the HTTP response object.\n\n\nset_status_code\n\n\nChanges the status code of the \nHttpResponse\n.\n\n\nInput:\n \nint\n\n\nset_header\n\n\nSets or modifies an HTTP header of the \nHttpResponse\n.\n\n\nInput:\n \nstring -> 'a\n\n\nset_body\n\n\nSets or modifies the body of the \nHttpResponse\n. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards any more.\n\n\nInput:\n \nbyte[]\n\n\ntext\n\n\nSets or modifies the body of the \nHttpResponse\n by sending a plain text value to the client. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards any more. It also sets the \nContent-Type\n HTTP header to \ntext/plain\n.\n\n\nInput:\n \nstring\n\n\njson\n\n\nSets or modifies the body of the \nHttpResponse\n by sending a JSON serialized object to the client. It uses JSON serializer configured by Giraffe. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards any more. It also sets the \nContent-Type\n HTTP header to \napplication/json\n.\n\n\nInput:\n \n'a\n\n\nxml\n\n\nSets or modifies the body of the \nHttpResponse\n by sending an XML serialized object to the client. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards anymore. It also sets the \nContent-Type\n HTTP header to \napplication/xml\n.\n\n\nInput:\n \n'a\n\n\nnegotiate\n\n\nSets or modifies the body of the \nHttpResponse\n by inspecting the \nAccept\n header of the HTTP request and deciding if the response should be sent in JSON or XML or plain text. If the client is indifferent then the default response will be sent in JSON. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards anymore.\n\n\nInput:\n \n'a\n\n\nnegotiate_with\n\n\nSets or modifies the body of the \nHttpResponse\n by inspecting the \nAccept\n header of the HTTP request and deciding in what mimeType the response should be sent. A dictionary of type \nIDictionary<string, obj -> HttpHandler>\n is used to determine which \nobj -> HttpHandler\n function should be used to convert an object into a \nHttpHandler\n for a given mime type. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards anymore.\n\n\nInput:\n \n(IDictionary<string, obj -> HttpHandler>) -> 'a\n\n\nhtml\n\n\nSets or modifies the body of the \nHttpResponse\n with the contents of a single string variable. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards anymore. Sets the HTTP header \nContent-Type\n to \ntext/html\n.\n\n\nInput:\n \nstring\n\n\nhtml_file\n\n\nSets or modifies the body of the \nHttpResponse\n with the contents of a physical html file. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards anymore. This HTTP handler takes a rooted path of a html file or a path which is relative to the ContentRootPath as the input parameter and sets the HTTP header \nContent-Type\n to \ntext/html\n.\n\n\nInput:\n \nstring\n\n\nrender_html\n\n\nA more functional way of generating HTML by composing HTML elements in F# to generate a rich Model-View output.\n\n\nInput:\n \nXmlNode\n \n\n\nredirect_to\n\n\nUses a 302 or 301 (when permanent) HTTP response code to redirect the client to the specified location. It takes in two parameters, a boolean flag denoting whether the redirect should be permanent or not and the location to redirect to.\n\n\nInput:\n \nbool -> string\n \n\n\nroute_ports\n\n\nIf your web server is listening to multiple ports then you can use the \nroutePorts\n HttpHandler to easily filter incoming requests based on their port by providing a list of port number and HttpHandler (\n(int * HttpHandler) list\n).\n\n\nInput:\n \n(int -> HttpHandler) list\n \n\n\nuse_warbler\n\n\nIf your route is not returning a static response, then you should wrap your function with a warbler. Functions in F# are eagerly evaluated and the warbler will help to evaluate the function every time the route is hit.\n\n\nInput:\n \nHttpHandler\n \n\n\n\n\nPipeline Helpers\n\n\nModule containing a couple of more advanced \nHttpHandlers\n commonly used in Saturn applications.\n\n\nacceptJson\n\n\nAccepts \nContentType\n \napplication/json\n.\n\n\nacceptXml\n\n\nAccepts \nContentType\n \napplication/xml\n.\n\n\nacceptHtml\n\n\nAccepts \nContentType\n \ntext/html\n.\n\n\nacceptMultipart\n\n\nAccepts \nContentType\n \nmultipart/form-data\n.\n\n\n\n\nputSecureBrowserHeaders\n\n\nAdds headers that improve browser security.\nIt sets the following headers:\n\n\n\n\nx-frame-options - set to SAMEORIGIN to avoid clickjacking through iframes unless in the same origin\n\n\nx-content-type-options - set to nosniff. This requires script and style tags to be sent with proper content type\n\n\nx-xss-protection - set to \"1; mode=block\" to improve XSS protection on both Chrome and IE\n\n\nx-download-options - set to noopen to instruct the browser not to open a download directly in the browser, to avoid HTML files rendering inline and accessing the security context of the application (like critical domain cookies)\n\n\nx-permitted-cross-domain-policies - set to none to restrict Adobe Flash Player\u2019s access to data\n\n\n\n\nenableCors\n\n\nEnables CORS protection using provided config. Use \nCORS.defaultCORSConfig\n for default configuration.\n\n\nInput:\n \nCORSConfig\n\n\nfetchSession\n\n\nFetches session from session provider. If it won't be called session will be synchronusly fetched on first usage.\n\n\nfetchModel\n\n\nTries to get the model from the request and puts the model into \nItems.RequestModel\n. If it won't be called content can be fetched using \nContext.Controller\n helpers.\nIt won't crash the pipelines if fetching failed.\nIt optionally takes custom culture name as arguments.\n\n\nInput:\n \nstring option\n\n\nhead\n\n\nConvert \nHEAD\n requests to \nGET\n requests.\n\n\nrequestId\n\n\nPipeline for generating a unique request ID for each request. A generated request ID will be in the format \nuq8hs30oafhj5vve8ji5pmp7mtopc08f\n.\nIf a request ID already exists as the \nx-request-id\n HTTP request header, then that value will be used assuming it is between 20 and 200 characters. If it is not, a new request ID will be generated.\nThe request ID is put into a \nx-request-id\n HTTP header and into the \nItems\n directory of the HttpContext with key \nRequestId\n.\n\n\nrequireHeader\n\n\nRequires the given value for the given request header.\n\n\nInput:\n \n(header:string) -> (value:string)",
            "title": "Pipeline"
        },
        {
            "location": "/api/pipeline/#pipeline",
            "text": "",
            "title": "Pipeline"
        },
        {
            "location": "/api/pipeline/#pipeline-builder",
            "text": "Computation expression used to combine  HttpHandlers  in a declarative manner.  The result of the computation expression is a standard Giraffe  HttpHandler  which means that it's easily composable with other parts of the Giraffe ecosystem.  Example:  let headerPipe = pipeline {\n    set_header \"myCustomHeader\" \"abcd\"\n    set_header \"myCustomHeader2\" \"zxcv\"\n}\n\nlet endpointPipe = pipeline {\n    plug fetchSession\n    plug head\n    plug requestId\n}",
            "title": "Pipeline builder"
        },
        {
            "location": "/api/pipeline/#plug",
            "text": "Enables adding any additional  HttpHandler  to the pipeline.  Input:   HttpHandler",
            "title": "plug"
        },
        {
            "location": "/api/pipeline/#must_accept",
            "text": "Filters a request by the  Accept  HTTP header. You can use it to check if a client accepts a certain MIME type before returning a response.  Input:   string",
            "title": "must_accept"
        },
        {
            "location": "/api/pipeline/#challenge",
            "text": "Challenges authentication with a specified authentication scheme.  Input:   string",
            "title": "challenge"
        },
        {
            "location": "/api/pipeline/#sign_off",
            "text": "Signs off the currently logged in user with a specified authentication scheme.  Input:   string",
            "title": "sign_off"
        },
        {
            "location": "/api/pipeline/#requires_auth_policy",
            "text": "Validates if a user satisfies policy requirement, if not the handler will execute the  authFailedHandler  function.  Input:   (ClaimsPrincipal -> bool) -> HttpHandler",
            "title": "requires_auth_policy"
        },
        {
            "location": "/api/pipeline/#requires_authentication",
            "text": "Validates if a user is authenticated/logged in. If the user is not authenticated then the handler will execute the  authFailedHandler  function.  Input:   HttpHandler",
            "title": "requires_authentication"
        },
        {
            "location": "/api/pipeline/#requires_role",
            "text": "Validates if an authenticated user is in a specified role. If the user fails to be in the required role then the handler will execute the  authFailedHandler  function.  Input:   string -> HttpHandler",
            "title": "requires_role"
        },
        {
            "location": "/api/pipeline/#requires_role_of",
            "text": "Validates if an authenticated user is in one of the supplied roles. If the user fails to be in one of the required roles then the handler will execute the  authFailedHandler  function.  Input:   string list-> HttpHandler",
            "title": "requires_role_of"
        },
        {
            "location": "/api/pipeline/#clear_response",
            "text": "Tries to clear the current response. This can be useful inside an error handler to reset the response before writing an error message to the body of the HTTP response object.",
            "title": "clear_response"
        },
        {
            "location": "/api/pipeline/#set_status_code",
            "text": "Changes the status code of the  HttpResponse .  Input:   int",
            "title": "set_status_code"
        },
        {
            "location": "/api/pipeline/#set_header",
            "text": "Sets or modifies an HTTP header of the  HttpResponse .  Input:   string -> 'a",
            "title": "set_header"
        },
        {
            "location": "/api/pipeline/#set_body",
            "text": "Sets or modifies the body of the  HttpResponse . This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards any more.  Input:   byte[]",
            "title": "set_body"
        },
        {
            "location": "/api/pipeline/#text",
            "text": "Sets or modifies the body of the  HttpResponse  by sending a plain text value to the client. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards any more. It also sets the  Content-Type  HTTP header to  text/plain .  Input:   string",
            "title": "text"
        },
        {
            "location": "/api/pipeline/#json",
            "text": "Sets or modifies the body of the  HttpResponse  by sending a JSON serialized object to the client. It uses JSON serializer configured by Giraffe. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards any more. It also sets the  Content-Type  HTTP header to  application/json .  Input:   'a",
            "title": "json"
        },
        {
            "location": "/api/pipeline/#xml",
            "text": "Sets or modifies the body of the  HttpResponse  by sending an XML serialized object to the client. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards anymore. It also sets the  Content-Type  HTTP header to  application/xml .  Input:   'a",
            "title": "xml"
        },
        {
            "location": "/api/pipeline/#negotiate",
            "text": "Sets or modifies the body of the  HttpResponse  by inspecting the  Accept  header of the HTTP request and deciding if the response should be sent in JSON or XML or plain text. If the client is indifferent then the default response will be sent in JSON. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards anymore.  Input:   'a",
            "title": "negotiate"
        },
        {
            "location": "/api/pipeline/#negotiate_with",
            "text": "Sets or modifies the body of the  HttpResponse  by inspecting the  Accept  header of the HTTP request and deciding in what mimeType the response should be sent. A dictionary of type  IDictionary<string, obj -> HttpHandler>  is used to determine which  obj -> HttpHandler  function should be used to convert an object into a  HttpHandler  for a given mime type. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards anymore.  Input:   (IDictionary<string, obj -> HttpHandler>) -> 'a",
            "title": "negotiate_with"
        },
        {
            "location": "/api/pipeline/#html",
            "text": "Sets or modifies the body of the  HttpResponse  with the contents of a single string variable. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards anymore. Sets the HTTP header  Content-Type  to  text/html .  Input:   string",
            "title": "html"
        },
        {
            "location": "/api/pipeline/#html_file",
            "text": "Sets or modifies the body of the  HttpResponse  with the contents of a physical html file. This HTTP handler triggers a response to the client and other HTTP handlers will not be able to modify the HTTP headers afterwards anymore. This HTTP handler takes a rooted path of a html file or a path which is relative to the ContentRootPath as the input parameter and sets the HTTP header  Content-Type  to  text/html .  Input:   string",
            "title": "html_file"
        },
        {
            "location": "/api/pipeline/#render_html",
            "text": "A more functional way of generating HTML by composing HTML elements in F# to generate a rich Model-View output.  Input:   XmlNode",
            "title": "render_html"
        },
        {
            "location": "/api/pipeline/#redirect_to",
            "text": "Uses a 302 or 301 (when permanent) HTTP response code to redirect the client to the specified location. It takes in two parameters, a boolean flag denoting whether the redirect should be permanent or not and the location to redirect to.  Input:   bool -> string",
            "title": "redirect_to"
        },
        {
            "location": "/api/pipeline/#route_ports",
            "text": "If your web server is listening to multiple ports then you can use the  routePorts  HttpHandler to easily filter incoming requests based on their port by providing a list of port number and HttpHandler ( (int * HttpHandler) list ).  Input:   (int -> HttpHandler) list",
            "title": "route_ports"
        },
        {
            "location": "/api/pipeline/#use_warbler",
            "text": "If your route is not returning a static response, then you should wrap your function with a warbler. Functions in F# are eagerly evaluated and the warbler will help to evaluate the function every time the route is hit.  Input:   HttpHandler",
            "title": "use_warbler"
        },
        {
            "location": "/api/pipeline/#pipeline-helpers",
            "text": "Module containing a couple of more advanced  HttpHandlers  commonly used in Saturn applications.",
            "title": "Pipeline Helpers"
        },
        {
            "location": "/api/pipeline/#acceptjson",
            "text": "Accepts  ContentType   application/json .",
            "title": "acceptJson"
        },
        {
            "location": "/api/pipeline/#acceptxml",
            "text": "Accepts  ContentType   application/xml .",
            "title": "acceptXml"
        },
        {
            "location": "/api/pipeline/#accepthtml",
            "text": "Accepts  ContentType   text/html .",
            "title": "acceptHtml"
        },
        {
            "location": "/api/pipeline/#acceptmultipart",
            "text": "Accepts  ContentType   multipart/form-data .",
            "title": "acceptMultipart"
        },
        {
            "location": "/api/pipeline/#putsecurebrowserheaders",
            "text": "Adds headers that improve browser security.\nIt sets the following headers:   x-frame-options - set to SAMEORIGIN to avoid clickjacking through iframes unless in the same origin  x-content-type-options - set to nosniff. This requires script and style tags to be sent with proper content type  x-xss-protection - set to \"1; mode=block\" to improve XSS protection on both Chrome and IE  x-download-options - set to noopen to instruct the browser not to open a download directly in the browser, to avoid HTML files rendering inline and accessing the security context of the application (like critical domain cookies)  x-permitted-cross-domain-policies - set to none to restrict Adobe Flash Player\u2019s access to data",
            "title": "putSecureBrowserHeaders"
        },
        {
            "location": "/api/pipeline/#enablecors",
            "text": "Enables CORS protection using provided config. Use  CORS.defaultCORSConfig  for default configuration.  Input:   CORSConfig",
            "title": "enableCors"
        },
        {
            "location": "/api/pipeline/#fetchsession",
            "text": "Fetches session from session provider. If it won't be called session will be synchronusly fetched on first usage.",
            "title": "fetchSession"
        },
        {
            "location": "/api/pipeline/#fetchmodel",
            "text": "Tries to get the model from the request and puts the model into  Items.RequestModel . If it won't be called content can be fetched using  Context.Controller  helpers.\nIt won't crash the pipelines if fetching failed.\nIt optionally takes custom culture name as arguments.  Input:   string option",
            "title": "fetchModel"
        },
        {
            "location": "/api/pipeline/#head",
            "text": "Convert  HEAD  requests to  GET  requests.",
            "title": "head"
        },
        {
            "location": "/api/pipeline/#requestid",
            "text": "Pipeline for generating a unique request ID for each request. A generated request ID will be in the format  uq8hs30oafhj5vve8ji5pmp7mtopc08f .\nIf a request ID already exists as the  x-request-id  HTTP request header, then that value will be used assuming it is between 20 and 200 characters. If it is not, a new request ID will be generated.\nThe request ID is put into a  x-request-id  HTTP header and into the  Items  directory of the HttpContext with key  RequestId .",
            "title": "requestId"
        },
        {
            "location": "/api/pipeline/#requireheader",
            "text": "Requires the given value for the given request header.  Input:   (header:string) -> (value:string)",
            "title": "requireHeader"
        },
        {
            "location": "/api/router/",
            "text": "Router\n\n\nRouter builder\n\n\nComputation expression used to create routing, combining \nHttpHandlers\n, \npipelines\n and \ncontrollers\n together.\n\n\nThe result of the computation expression is a standard Giraffe \nHttpHandler\n, which means that it's easily composable with other parts of the ecosytem.\n\n\nExample:\n\n\nlet topRouter = router {\n    pipe_through headerPipe\n    not_found_handler (text \"404\")\n\n    get \"/\" helloWorld\n    get \"/a\" helloWorld2\n    getf \"/name/%s\" helloWorldName\n    getf \"/name/%s/%i\" helloWorldNameAge\n\n    //routers can be defined inline to simulate `subRoute` combinator\n    forward \"/other\" (router {\n        pipe_through otherHeaderPipe\n        not_found_handler (text \"Other 404\")\n\n        get \"/\" otherHelloWorld\n        get \"/a\" otherHelloWorld2\n    })\n\n    // or can be defined separatly and used as HttpHandler\n    forward \"/api\" apiRouter\n\n    // same with controllers\n    forward \"/users\" userController\n}\n\n\n\n\n\n\nget\n\n\nAdds handler for \nGET\n request.\n\n\nInput:\n \nstring * HttpHandler\n\n\ngetf\n\n\nAdds handler for \nGET\n request using formatter.\n\n\nInput:\n \nPrintfFormat<_,_,_,_'f> * ('f -> HttpHandler)\n\n\npost\n\n\nAdds handler for \nPOST\n request.\n\n\nInput:\n \nstring * HttpHandler\n\n\npostf\n\n\nAdds handler for \nPOST\n request using formatter.\n\n\nInput:\n \nPrintfFormat<_,_,_,_'f> * ('f -> HttpHandler)\n\n\nput\n\n\nAdds handler for \nPUT\n request.\n\n\nInput:\n \nstring * HttpHandler\n\n\nputf\n\n\nAdds handler for \nPUT\n request using formatter.\n\n\nInput:\n \nPrintfFormat<_,_,_,_'f> * ('f -> HttpHandler)\n\n\ndelete\n\n\nAdds handler for \nDELETE\n request.\n\n\nInput:\n \nstring * HttpHandler\n\n\ndeletef\n\n\nAdds handler for \nDELETE\n request using formatter.\n\n\nInput:\n \nPrintfFormat<_,_,_,_'f> * ('f -> HttpHandler)\n\n\npatch\n\n\nAdds handler for \nPATCH\n request.\n\n\nInput:\n \nstring * HttpHandler\n\n\npatchf\n\n\nAdds handler for \nPATCH\n request using formatter.\n\n\nInput:\n \nPrintfFormat<_,_,_,_'f> * ('f -> HttpHandler)\n\n\nforward\n\n\nForwards calls to different \nrouter\n. Modifies the \nHttpRequest.Path\n to allow subrouting.\n\n\nInput:\n \nstring * HttpHandler\n\n\npipe_through\n\n\nAdds a pipeline to the list of pipelines that will be used for every request\n\n\nInput:\n \nHttpHandler\n\n\nnot_found_handler\n\n\nAdds not-found handler for current router\n\n\nInput:\n \nHttpHandler",
            "title": "Router"
        },
        {
            "location": "/api/router/#router",
            "text": "",
            "title": "Router"
        },
        {
            "location": "/api/router/#router-builder",
            "text": "Computation expression used to create routing, combining  HttpHandlers ,  pipelines  and  controllers  together.  The result of the computation expression is a standard Giraffe  HttpHandler , which means that it's easily composable with other parts of the ecosytem.  Example:  let topRouter = router {\n    pipe_through headerPipe\n    not_found_handler (text \"404\")\n\n    get \"/\" helloWorld\n    get \"/a\" helloWorld2\n    getf \"/name/%s\" helloWorldName\n    getf \"/name/%s/%i\" helloWorldNameAge\n\n    //routers can be defined inline to simulate `subRoute` combinator\n    forward \"/other\" (router {\n        pipe_through otherHeaderPipe\n        not_found_handler (text \"Other 404\")\n\n        get \"/\" otherHelloWorld\n        get \"/a\" otherHelloWorld2\n    })\n\n    // or can be defined separatly and used as HttpHandler\n    forward \"/api\" apiRouter\n\n    // same with controllers\n    forward \"/users\" userController\n}",
            "title": "Router builder"
        },
        {
            "location": "/api/router/#get",
            "text": "Adds handler for  GET  request.  Input:   string * HttpHandler",
            "title": "get"
        },
        {
            "location": "/api/router/#getf",
            "text": "Adds handler for  GET  request using formatter.  Input:   PrintfFormat<_,_,_,_'f> * ('f -> HttpHandler)",
            "title": "getf"
        },
        {
            "location": "/api/router/#post",
            "text": "Adds handler for  POST  request.  Input:   string * HttpHandler",
            "title": "post"
        },
        {
            "location": "/api/router/#postf",
            "text": "Adds handler for  POST  request using formatter.  Input:   PrintfFormat<_,_,_,_'f> * ('f -> HttpHandler)",
            "title": "postf"
        },
        {
            "location": "/api/router/#put",
            "text": "Adds handler for  PUT  request.  Input:   string * HttpHandler",
            "title": "put"
        },
        {
            "location": "/api/router/#putf",
            "text": "Adds handler for  PUT  request using formatter.  Input:   PrintfFormat<_,_,_,_'f> * ('f -> HttpHandler)",
            "title": "putf"
        },
        {
            "location": "/api/router/#delete",
            "text": "Adds handler for  DELETE  request.  Input:   string * HttpHandler",
            "title": "delete"
        },
        {
            "location": "/api/router/#deletef",
            "text": "Adds handler for  DELETE  request using formatter.  Input:   PrintfFormat<_,_,_,_'f> * ('f -> HttpHandler)",
            "title": "deletef"
        },
        {
            "location": "/api/router/#patch",
            "text": "Adds handler for  PATCH  request.  Input:   string * HttpHandler",
            "title": "patch"
        },
        {
            "location": "/api/router/#patchf",
            "text": "Adds handler for  PATCH  request using formatter.  Input:   PrintfFormat<_,_,_,_'f> * ('f -> HttpHandler)",
            "title": "patchf"
        },
        {
            "location": "/api/router/#forward",
            "text": "Forwards calls to different  router . Modifies the  HttpRequest.Path  to allow subrouting.  Input:   string * HttpHandler",
            "title": "forward"
        },
        {
            "location": "/api/router/#pipe_through",
            "text": "Adds a pipeline to the list of pipelines that will be used for every request  Input:   HttpHandler",
            "title": "pipe_through"
        },
        {
            "location": "/api/router/#not_found_handler",
            "text": "Adds not-found handler for current router  Input:   HttpHandler",
            "title": "not_found_handler"
        },
        {
            "location": "/api/controller/",
            "text": "Controller\n\n\nAction\n\n\ntype Action =\n    | Index\n    | Show\n    | Add\n    | Edit\n    | Create\n    | Update\n    | Patch\n    | Delete\n    | DeleteAll\n    | All\n\n\n\n\n\n\nController helpers\n\n\nModule with high level helper functions that are usually used in controller actions.\n\n\n\n\njson\n\n\nReturns to the client content serialized to JSON.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\nxml\n\n\nReturns to the client content serialized to XML.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\ntext\n\n\nReturns to the client content as string.\n\n\nType:\n \nHttpContext -> string -> HttpFuncResult\n\n\nrender\n\n\nReturns to the client rendered template.\n\n\nType:\n \nHttpContext -> string -> HttpFuncResult\n\n\nfile\n\n\nReturns to the client a static file.\n\n\nType:\n \nHttpContext -> string -> HttpFuncResult\n\n\nsendDownload\n\n\nSends file with given path.\n\n\nType:\n \nHttpContext -> string -> HttpFuncResult\n\n\nsendDownloadBinary\n\n\nSends file as binary blob.\n\n\nType:\n \nHttpContext -> byte [] -> HttpFuncResult\n\n\nredirect\n\n\nSends redirect response.\n\n\nType:\n \nHttpContext -> string -> HttpFuncResult\n\n\n\n\ngetJson<'a>\n\n\nGets model from body as JSON.\n\n\nType:\n \nHttpContext -> Task<'a>\n\n\ngetXml<'a>\n\n\nGets model from body as XML.\n\n\nType:\n \nHttpContext -> Task<'a>\n\n\ngetForm<'a>\n\n\nGets model from urelencoded body.\n\n\nType:\n \nHttpContext -> Task<'a>\n\n\ngetQuery<'a>\n\n\nGets model from query string.\n\n\nType:\n \nHttpContext -> Task<'a>\n\n\ngetModel<'a>\n\n\nGet model based on \nHttpMethod\n and \nContent-Type\n of request.\n\n\nType:\n \nHttpContext -> Task<'a>\n\n\nloadModel<'a>\n\n\nLoads model populated by \nfetchModel\n pipeline.\n\n\nType:\n \nHttpContext -> Option<'a>\n\n\ngetPath\n\n\nGets path of the request relative to the current \nrouter\n.\n\n\nType:\n \nHttpContext -> string\n\n\ngetUrl\n\n\nGets the request URL.\n\n\nType:\n \nHttpContext -> string option\n\n\ngetConfig<'a>\n\n\nGets configuration.\n\n\nType:\n \nHttpContext -> 'a\n\n\n\n\nResponse helpers\n\n\nModule with lower level functions for returning certain responses from the action.\n\n\n\n\ncontinue\n\n\nReturns \n100 Continue\n.\n\n\nType:\n \nHttpContext -> HttpFuncResult\n\n\nswitchingProto\n\n\nReturns \n101 Switching Protocols\n.\n\n\nType:\n \nHttpContext -> HttpFuncResult\n\n\n\n\nok\n\n\nReturns \n200 OK\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\ncreated\n\n\nReturns \n201 Created\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\naccepted\n\n\nReturns \n202 Accepted\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\n\n\nbadRequest\n\n\nReturns \n400 Bad Request\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\nunauthorized\n\n\nReturns \n401 Unauthorized\n. Requires \nscheme\n and \nrelam\n.\n\n\nType:\n \nHttpContext -> string -> string -> 'a -> HttpFuncResult\n\n\nforbidden\n\n\nReturns \n403 Forbidden\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\nnotFound\n\n\nReturns \n404 Not Found\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\nmethodNotAllowed\n\n\nReturns \n405 Method Not Allowed\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\nnotAcceptable\n\n\nReturns \n406 Not Acceptable\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\nconflict\n\n\nReturns \n409 Conflict\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\ngone\n\n\nReturns \n410 Gone\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\nunuspportedMediaType\n\n\nReturns \n415 Unsupported Media Type\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\nunprocessableEntity\n\n\nReturns \n422 Unprocessable Entity\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\npreconditionRequired\n\n\nReturns \n428 Precondition Required\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\ntooManyRequests\n\n\nReturns \n429 Too Many Requests\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\n\n\ninternalError\n\n\nReturns \n500 Internal Server Error\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\nnotImplemented\n\n\nReturns \n501 Not Implemented\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\nbadGateway\n\n\nReturns \n502 Bad Gateway\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\nserviceUnavailable\n\n\nReturns \n503 Service Unavailable\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\ngatewayTimeout\n\n\nReturns \n504 Gateway Timeout\n.\n\n\nType:\n \nHttpContext -> 'a -> HttpFuncResult\n\n\n\n\nController builder\n\n\nComputation expression used to create Saturn controllers - abstraction representing REST-ish endpoint for serving HTML views or returning data. It supports:\n\n\n\n\na set of predefined actions that are automatically mapped to the endpoints following standard conventions\n\n\nembedding sub-controllers for modeling one-to-many relationships \n\n\nversioning \n\n\nadding plugs for a particular action which in principle provides the same mechanism as attributes in ASP.NET MVC applications\n\n\ndefining a common error handler for all actions\n\n\ndefining a not-found action\n\n\n\n\nThe result of the computation expression is a standard Giraffe \nHttpHandler\n, which means that it's easily composable with other parts of the ecosytem.\n\n\nExample:\n\n\nlet commentController userId = controller {\n    index (fun ctx -> (sprintf \"Comment Index handler for user %i\" userId ) |> Controller.text ctx)\n    add (fun ctx -> (sprintf \"Comment Add handler for user %i\" userId ) |> Controller.text ctx)\n    show (fun (ctx, id) -> (sprintf \"Show comment %s handler for user %i\" id userId ) |> Controller.text ctx)\n    edit (fun (ctx, id) -> (sprintf \"Edit comment %s handler for user %i\" id userId )  |> Controller.text ctx)\n}\n\nlet userControllerVersion1 = controller {\n    version 1\n    subController \"/comments\" commentController\n\n    index (fun ctx -> \"Index handler version 1\" |> Controller.text ctx)\n    add (fun ctx -> \"Add handler version 1\" |> Controller.text ctx)\n    show (fun (ctx, id) -> (sprintf \"Show handler version 1 - %i\" id) |> Controller.text ctx)\n    edit (fun (ctx, id) -> (sprintf \"Edit handler version 1 - %i\" id) |> Controller.text ctx)\n}\n\nlet userController = controller {\n    subController \"/comments\" commentController\n\n    plug [All] (setHttpHeader \"user-controller-common\" \"123\")\n    plug [Index; Show] (setHttpHeader \"user-controller-specialized\" \"123\")\n\n    index (fun ctx -> \"Index handler no version\" |> Controller.text ctx)\n    add (fun ctx -> \"Add handler no version\" |> Controller.text ctx)\n    show (fun (ctx, id) -> (sprintf \"Show handler no version - %i\" id) |> Controller.text ctx)\n    edit (fun (ctx, id) -> (sprintf \"Edit handler no version - %i\" id) |> Controller.text ctx)\n}\n\n\n\n\n\n\nindex\n\n\nOperation that should render (or return in case of API controllers) a list of data.\n\n\nMapped to \nGET \"/\"\n endpoint\n\n\nInput:\n \nHttpContext -> HttpFuncResult\n\n\nshow\n\n\nOperation that should render (or return in case of API controllers) a single entry of data.\n\n\nMapped to \nGET \"/:id\"\n endpoint\n\n\nInput:\n \nHttpContext * 'Key -> HttpFuncResult\n\n\nadd\n\n\nOperation that should render a form for adding a new item.\n\n\nMapped to \nGET \"/add\"\n endpoint\n\n\nInput:\n \nHttpContext -> HttpFuncResult\n\n\nedit\n\n\nOperation that should render a form for editing an existing item.\n\n\nMapped to \nGET \"/:id/edit\"\n endpoint\n\n\nInput:\n \nHttpContext * 'Key -> HttpFuncResult\n\n\ncreate\n\n\nOperation that creates a new item.\n\n\nMapped to \nPOST \"/\"\n and endpoint\n\n\nInput:\n \nHttpContext -> HttpFuncResult\n\n\nupdate\n\n\nOperation that updates an existing item.\n\n\nMapped to \nPOST \"/:id\"\n and \nPATCH \"/:id\"\n endpoint\n\n\nInput:\n \nHttpContext * 'Key -> HttpFuncResult\n\n\ndelete\n\n\nOperation that deletes an existing item.\n\n\nMapped to \nDELETE \"/:id\"\n endpoint\n\n\nInput:\n \nHttpContext * 'Key -> HttpFuncResult\n\n\ndelete_all\n\n\nOperation that deletes all items.\n\n\nMapped to \nDELETE \"/\"\n endpoint\n\n\nInput:\n \nHttpContext -> HttpFuncResult\n\n\n\n\nnot_found_handler\n\n\nDefine not-found handler for the controller.\n\n\nInput:\n \nHttpContext -> HttpFuncResult\n\n\nerror_handler\n\n\nDefine error handler for the controller.\n\n\nInput:\n \nHttpContext * Exception -> HttpFuncResult\n\n\nsubController\n\n\nAdd subcontroller\n\n\nForward to subcontroller all calls to \n/:id/:controller_name\n endpoint.\n\n\nInput:\n \nstring * ('a -> HttpHandler)\n\n\nversion\n\n\nDefine the controller version. Adds checking of \nx-controller-version\n header.\n\n\nInput:\n \nint\n\n\nplug\n\n\nPlugs given \nHttpHandler\n for some \nAction\ns in the controller.\n\n\nInput:\n \nAction list * HttpHandler",
            "title": "Controller"
        },
        {
            "location": "/api/controller/#controller",
            "text": "",
            "title": "Controller"
        },
        {
            "location": "/api/controller/#action",
            "text": "type Action =\n    | Index\n    | Show\n    | Add\n    | Edit\n    | Create\n    | Update\n    | Patch\n    | Delete\n    | DeleteAll\n    | All",
            "title": "Action"
        },
        {
            "location": "/api/controller/#controller-helpers",
            "text": "Module with high level helper functions that are usually used in controller actions.",
            "title": "Controller helpers"
        },
        {
            "location": "/api/controller/#json",
            "text": "Returns to the client content serialized to JSON.  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "json"
        },
        {
            "location": "/api/controller/#xml",
            "text": "Returns to the client content serialized to XML.  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "xml"
        },
        {
            "location": "/api/controller/#text",
            "text": "Returns to the client content as string.  Type:   HttpContext -> string -> HttpFuncResult",
            "title": "text"
        },
        {
            "location": "/api/controller/#render",
            "text": "Returns to the client rendered template.  Type:   HttpContext -> string -> HttpFuncResult",
            "title": "render"
        },
        {
            "location": "/api/controller/#file",
            "text": "Returns to the client a static file.  Type:   HttpContext -> string -> HttpFuncResult",
            "title": "file"
        },
        {
            "location": "/api/controller/#senddownload",
            "text": "Sends file with given path.  Type:   HttpContext -> string -> HttpFuncResult",
            "title": "sendDownload"
        },
        {
            "location": "/api/controller/#senddownloadbinary",
            "text": "Sends file as binary blob.  Type:   HttpContext -> byte [] -> HttpFuncResult",
            "title": "sendDownloadBinary"
        },
        {
            "location": "/api/controller/#redirect",
            "text": "Sends redirect response.  Type:   HttpContext -> string -> HttpFuncResult",
            "title": "redirect"
        },
        {
            "location": "/api/controller/#getjsona",
            "text": "Gets model from body as JSON.  Type:   HttpContext -> Task<'a>",
            "title": "getJson&lt;'a&gt;"
        },
        {
            "location": "/api/controller/#getxmla",
            "text": "Gets model from body as XML.  Type:   HttpContext -> Task<'a>",
            "title": "getXml&lt;'a&gt;"
        },
        {
            "location": "/api/controller/#getforma",
            "text": "Gets model from urelencoded body.  Type:   HttpContext -> Task<'a>",
            "title": "getForm&lt;'a&gt;"
        },
        {
            "location": "/api/controller/#getquerya",
            "text": "Gets model from query string.  Type:   HttpContext -> Task<'a>",
            "title": "getQuery&lt;'a&gt;"
        },
        {
            "location": "/api/controller/#getmodela",
            "text": "Get model based on  HttpMethod  and  Content-Type  of request.  Type:   HttpContext -> Task<'a>",
            "title": "getModel&lt;'a&gt;"
        },
        {
            "location": "/api/controller/#loadmodela",
            "text": "Loads model populated by  fetchModel  pipeline.  Type:   HttpContext -> Option<'a>",
            "title": "loadModel&lt;'a&gt;"
        },
        {
            "location": "/api/controller/#getpath",
            "text": "Gets path of the request relative to the current  router .  Type:   HttpContext -> string",
            "title": "getPath"
        },
        {
            "location": "/api/controller/#geturl",
            "text": "Gets the request URL.  Type:   HttpContext -> string option",
            "title": "getUrl"
        },
        {
            "location": "/api/controller/#getconfiga",
            "text": "Gets configuration.  Type:   HttpContext -> 'a",
            "title": "getConfig&lt;'a&gt;"
        },
        {
            "location": "/api/controller/#response-helpers",
            "text": "Module with lower level functions for returning certain responses from the action.",
            "title": "Response helpers"
        },
        {
            "location": "/api/controller/#continue",
            "text": "Returns  100 Continue .  Type:   HttpContext -> HttpFuncResult",
            "title": "continue"
        },
        {
            "location": "/api/controller/#switchingproto",
            "text": "Returns  101 Switching Protocols .  Type:   HttpContext -> HttpFuncResult",
            "title": "switchingProto"
        },
        {
            "location": "/api/controller/#ok",
            "text": "Returns  200 OK .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "ok"
        },
        {
            "location": "/api/controller/#created",
            "text": "Returns  201 Created .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "created"
        },
        {
            "location": "/api/controller/#accepted",
            "text": "Returns  202 Accepted .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "accepted"
        },
        {
            "location": "/api/controller/#badrequest",
            "text": "Returns  400 Bad Request .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "badRequest"
        },
        {
            "location": "/api/controller/#unauthorized",
            "text": "Returns  401 Unauthorized . Requires  scheme  and  relam .  Type:   HttpContext -> string -> string -> 'a -> HttpFuncResult",
            "title": "unauthorized"
        },
        {
            "location": "/api/controller/#forbidden",
            "text": "Returns  403 Forbidden .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "forbidden"
        },
        {
            "location": "/api/controller/#notfound",
            "text": "Returns  404 Not Found .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "notFound"
        },
        {
            "location": "/api/controller/#methodnotallowed",
            "text": "Returns  405 Method Not Allowed .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "methodNotAllowed"
        },
        {
            "location": "/api/controller/#notacceptable",
            "text": "Returns  406 Not Acceptable .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "notAcceptable"
        },
        {
            "location": "/api/controller/#conflict",
            "text": "Returns  409 Conflict .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "conflict"
        },
        {
            "location": "/api/controller/#gone",
            "text": "Returns  410 Gone .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "gone"
        },
        {
            "location": "/api/controller/#unuspportedmediatype",
            "text": "Returns  415 Unsupported Media Type .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "unuspportedMediaType"
        },
        {
            "location": "/api/controller/#unprocessableentity",
            "text": "Returns  422 Unprocessable Entity .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "unprocessableEntity"
        },
        {
            "location": "/api/controller/#preconditionrequired",
            "text": "Returns  428 Precondition Required .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "preconditionRequired"
        },
        {
            "location": "/api/controller/#toomanyrequests",
            "text": "Returns  429 Too Many Requests .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "tooManyRequests"
        },
        {
            "location": "/api/controller/#internalerror",
            "text": "Returns  500 Internal Server Error .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "internalError"
        },
        {
            "location": "/api/controller/#notimplemented",
            "text": "Returns  501 Not Implemented .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "notImplemented"
        },
        {
            "location": "/api/controller/#badgateway",
            "text": "Returns  502 Bad Gateway .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "badGateway"
        },
        {
            "location": "/api/controller/#serviceunavailable",
            "text": "Returns  503 Service Unavailable .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "serviceUnavailable"
        },
        {
            "location": "/api/controller/#gatewaytimeout",
            "text": "Returns  504 Gateway Timeout .  Type:   HttpContext -> 'a -> HttpFuncResult",
            "title": "gatewayTimeout"
        },
        {
            "location": "/api/controller/#controller-builder",
            "text": "Computation expression used to create Saturn controllers - abstraction representing REST-ish endpoint for serving HTML views or returning data. It supports:   a set of predefined actions that are automatically mapped to the endpoints following standard conventions  embedding sub-controllers for modeling one-to-many relationships   versioning   adding plugs for a particular action which in principle provides the same mechanism as attributes in ASP.NET MVC applications  defining a common error handler for all actions  defining a not-found action   The result of the computation expression is a standard Giraffe  HttpHandler , which means that it's easily composable with other parts of the ecosytem.  Example:  let commentController userId = controller {\n    index (fun ctx -> (sprintf \"Comment Index handler for user %i\" userId ) |> Controller.text ctx)\n    add (fun ctx -> (sprintf \"Comment Add handler for user %i\" userId ) |> Controller.text ctx)\n    show (fun (ctx, id) -> (sprintf \"Show comment %s handler for user %i\" id userId ) |> Controller.text ctx)\n    edit (fun (ctx, id) -> (sprintf \"Edit comment %s handler for user %i\" id userId )  |> Controller.text ctx)\n}\n\nlet userControllerVersion1 = controller {\n    version 1\n    subController \"/comments\" commentController\n\n    index (fun ctx -> \"Index handler version 1\" |> Controller.text ctx)\n    add (fun ctx -> \"Add handler version 1\" |> Controller.text ctx)\n    show (fun (ctx, id) -> (sprintf \"Show handler version 1 - %i\" id) |> Controller.text ctx)\n    edit (fun (ctx, id) -> (sprintf \"Edit handler version 1 - %i\" id) |> Controller.text ctx)\n}\n\nlet userController = controller {\n    subController \"/comments\" commentController\n\n    plug [All] (setHttpHeader \"user-controller-common\" \"123\")\n    plug [Index; Show] (setHttpHeader \"user-controller-specialized\" \"123\")\n\n    index (fun ctx -> \"Index handler no version\" |> Controller.text ctx)\n    add (fun ctx -> \"Add handler no version\" |> Controller.text ctx)\n    show (fun (ctx, id) -> (sprintf \"Show handler no version - %i\" id) |> Controller.text ctx)\n    edit (fun (ctx, id) -> (sprintf \"Edit handler no version - %i\" id) |> Controller.text ctx)\n}",
            "title": "Controller builder"
        },
        {
            "location": "/api/controller/#index",
            "text": "Operation that should render (or return in case of API controllers) a list of data.  Mapped to  GET \"/\"  endpoint  Input:   HttpContext -> HttpFuncResult",
            "title": "index"
        },
        {
            "location": "/api/controller/#show",
            "text": "Operation that should render (or return in case of API controllers) a single entry of data.  Mapped to  GET \"/:id\"  endpoint  Input:   HttpContext * 'Key -> HttpFuncResult",
            "title": "show"
        },
        {
            "location": "/api/controller/#add",
            "text": "Operation that should render a form for adding a new item.  Mapped to  GET \"/add\"  endpoint  Input:   HttpContext -> HttpFuncResult",
            "title": "add"
        },
        {
            "location": "/api/controller/#edit",
            "text": "Operation that should render a form for editing an existing item.  Mapped to  GET \"/:id/edit\"  endpoint  Input:   HttpContext * 'Key -> HttpFuncResult",
            "title": "edit"
        },
        {
            "location": "/api/controller/#create",
            "text": "Operation that creates a new item.  Mapped to  POST \"/\"  and endpoint  Input:   HttpContext -> HttpFuncResult",
            "title": "create"
        },
        {
            "location": "/api/controller/#update",
            "text": "Operation that updates an existing item.  Mapped to  POST \"/:id\"  and  PATCH \"/:id\"  endpoint  Input:   HttpContext * 'Key -> HttpFuncResult",
            "title": "update"
        },
        {
            "location": "/api/controller/#delete",
            "text": "Operation that deletes an existing item.  Mapped to  DELETE \"/:id\"  endpoint  Input:   HttpContext * 'Key -> HttpFuncResult",
            "title": "delete"
        },
        {
            "location": "/api/controller/#delete_all",
            "text": "Operation that deletes all items.  Mapped to  DELETE \"/\"  endpoint  Input:   HttpContext -> HttpFuncResult",
            "title": "delete_all"
        },
        {
            "location": "/api/controller/#not_found_handler",
            "text": "Define not-found handler for the controller.  Input:   HttpContext -> HttpFuncResult",
            "title": "not_found_handler"
        },
        {
            "location": "/api/controller/#error_handler",
            "text": "Define error handler for the controller.  Input:   HttpContext * Exception -> HttpFuncResult",
            "title": "error_handler"
        },
        {
            "location": "/api/controller/#subcontroller",
            "text": "Add subcontroller  Forward to subcontroller all calls to  /:id/:controller_name  endpoint.  Input:   string * ('a -> HttpHandler)",
            "title": "subController"
        },
        {
            "location": "/api/controller/#version",
            "text": "Define the controller version. Adds checking of  x-controller-version  header.  Input:   int",
            "title": "version"
        },
        {
            "location": "/api/controller/#plug",
            "text": "Plugs given  HttpHandler  for some  Action s in the controller.  Input:   Action list * HttpHandler",
            "title": "plug"
        },
        {
            "location": "/api/application/",
            "text": "Application\n\n\nrun\n\n\nRuns Saturn application.\n\n\nInput:\n \nIWebHostBuilder\n\n\nApplication builder\n\n\nComputation expression used to configure Saturn application. Under the hood it's using ASP.NET application configurations interfaces such as \nIWebHostBuilder\n, \nIServiceCollection\n, \nIApplicationBuilder\n and others. It aims to hide cumbersome ASP.NET application configuration and enable high level, declarative application configuration using feature toggles.\n\n\nExample:\n\n\nlet app = application {\n    pipe_through endpointPipe\n\n    use_router topRouter\n    url \"http://0.0.0.0:8085/\"\n    memory_cache\n    use_static \"static\"\n    use_gzip\n}\n\n\n\n\n\n\nuse_router\n\n\nDefines top-level router used for the application. It calls \nIApplicationBuilder.UseGiraffe\n.\n\n\nInput:\n \nHttpHandler\n\n\napplication {\n    ...\n    use_router myRouter\n}\n\n\n\n\npipe_through\n\n\nAdds pipeline to the list of pipelines that will be used for every request.\n\n\nInput:\n \nHttpHandler\n\n\napplication {\n    ...\n    pipe_through requestId\n}\n\n\n\n\nerror_handler\n\n\nAdds global error handler for exceptions not handled anywhere else. It uses \nIApplicationBuilder.UseGiraffeErrorHandler\n.\n\n\nInput:\n \nException -> ILogger -> HttpHandler\n\n\napplication {\n    ...\n    error_handler (fun e log -> text e.Message)\n}\n\n\n\n\nurl\n\n\nDefines the URL on which the application will be hosted. Should include port.\n\n\nInput:\n \nstring\n\n\napplication {\n    ...\n    url \"http://0.0.0.0:8085/\"\n}\n\n\n\n\nmemory_cache\n\n\nEnables in-memory session cache. Required if you used \nfetchSession\n plug.\n\n\napplication {\n    ...\n    memory_cache\n}\n\n\n\n\nuse_gzip\n\n\nEnables automatic gzip compression.\n\n\napplication {\n    ...\n    use_gzip\n}\n\n\n\n\nuse_static\n\n\nEnables static file hosting. Input path defines \nWebRoot\n and \nContentRoot\n of application.\n\n\nInput:\n \nstring\n\n\napplication {\n    ...\n    use_static \"static\"\n}\n\n\n\n\nuse_config\n\n\nDefines configuration that can be used with the \nHttpContext.GetConfiguration()\n function. The configuration function is evaluated once, during first request of the application.\n\n\nInput:\n \nunit -> 'a\n\n\napplication {\n    ...\n    use_config (fun _ -> \"config\")\n}\n\n\n\n\nforce_ssl\n\n\nRedirect all HTTP request to HTTPS.\n\n\napplication {\n    ...\n    force_ssl\n}\n\n\n\n\nuse_cors\n\n\nEnables application level CORS protection. First parameter is the name of the policy. Second parameter is configuration builder setting policy options.\n\n\nInput:\n \nstring -> (CorsPolicyBuilder -> unit)\n\n\napplication {\n    ...\n    use_cors \"CORS_policy\" (fun builder -> ())\n}\n\n\n\n\nuse_iis\n\n\nEnables IIS integration.\n\n\napplication {\n    ...\n    use_iis\n}\n\n\n\n\n\n\nuse_jwt_authentication\n\n\nEnables default JWT authentication. The first parameter is a private key used in signing. The second one defines the issuer of the token.\n\n\nInput:\n \nstring -> string\n\n\napplication {\n    ...\n    use_jwt_authentication \"mySecretKey\" \"lambdafactory.io\"\n}\n\n\n\n\nuse_jwt_authentication_with_config\n\n\nEnables JWT authentication with custom configuration.\n\n\nInput:\n \nJwtBearerOptions -> unit\n\n\napplication {\n    ...\n    use_jwt_authentication_with_config (fun opts -> ())\n}\n\n\n\n\nuse_cookies_authentication\n\n\nEnables default cookies authentication.\n\n\nInput:\n \nstring\n\n\napplication {\n    ...\n    use_cookies_authentication \"lambdafactory.io\"\n}\n\n\n\n\nuse_cookies_authentication_with_config\n\n\nEnables cookies authentication with custom configuration.\n\n\nInput:\n \nCookieAuthenticationOptions -> unit\n\n\napplication {\n    ...\n    use_cookies_authentication_with_config (fun opts -> ())\n}\n\n\n\n\nuse_github_oauth\n\n\nEnables default GitHub OAuth authentication.\n\n\nInput:\n \nstring -> string -> string\n\n\napplication {\n    ...\n    use_github_oauth \"myClientId\" \"myClientSecret\" \"/login\"\n}\n\n\n\n\nuse_github_oauth_with_config\n\n\nEnables GitHub OAuth authentication with custom configuration.\n\n\nInput:\n \nOAuthOptions -> unit\n\n\napplication {\n    ...\n    use_github_oauth (fun opts -> ())\n}\n\n\n\n\nuse_custom_oauth\n\n\nEnables custom OAuth authentication.\n\n\nInput:\n \nstring -> (OAuthOptions -> unit)\n\n\napplication {\n    ...\n    use_custom_oauth \"LinkedIn\" (fun opts -> ())\n}\n\n\n\n\n\n\n\n\nThe functions below enable you to add any configuration using standard ASP.NET builders\n\n\n\n\napp_config\n\n\nAdds custom application configuration step.\n\n\nInput:\n \nIApplicationBuilder -> IApplicationBuilder\n\n\nhost_config\n\n\nAdds custom host configuration step.\n\n\nInput:\n \nIWebHostBuilder -> IWebHostBuilder\n\n\nservice_config\n\n\nAdds custom service configuration step.\n\n\nInput:\n \nIServiceCollection -> IServiceCollection\n\n\nlet serviceConfig (services: IServiceCollection) =\n    services.AddSingleton<IMySingleton, MySingleton>()\n    services.AddTransient<SomeTransientService>()\n\nlet app = application {\n    ...\n    service_config serviceConfig\n}\n\n\n\n\nlogging\n\n\nAdds logging configuration.\n\n\nInput:\n \nIloggingBuilder -> unit",
            "title": "Application"
        },
        {
            "location": "/api/application/#application",
            "text": "",
            "title": "Application"
        },
        {
            "location": "/api/application/#run",
            "text": "Runs Saturn application.  Input:   IWebHostBuilder",
            "title": "run"
        },
        {
            "location": "/api/application/#application-builder",
            "text": "Computation expression used to configure Saturn application. Under the hood it's using ASP.NET application configurations interfaces such as  IWebHostBuilder ,  IServiceCollection ,  IApplicationBuilder  and others. It aims to hide cumbersome ASP.NET application configuration and enable high level, declarative application configuration using feature toggles.  Example:  let app = application {\n    pipe_through endpointPipe\n\n    use_router topRouter\n    url \"http://0.0.0.0:8085/\"\n    memory_cache\n    use_static \"static\"\n    use_gzip\n}",
            "title": "Application builder"
        },
        {
            "location": "/api/application/#use_router",
            "text": "Defines top-level router used for the application. It calls  IApplicationBuilder.UseGiraffe .  Input:   HttpHandler  application {\n    ...\n    use_router myRouter\n}",
            "title": "use_router"
        },
        {
            "location": "/api/application/#pipe_through",
            "text": "Adds pipeline to the list of pipelines that will be used for every request.  Input:   HttpHandler  application {\n    ...\n    pipe_through requestId\n}",
            "title": "pipe_through"
        },
        {
            "location": "/api/application/#error_handler",
            "text": "Adds global error handler for exceptions not handled anywhere else. It uses  IApplicationBuilder.UseGiraffeErrorHandler .  Input:   Exception -> ILogger -> HttpHandler  application {\n    ...\n    error_handler (fun e log -> text e.Message)\n}",
            "title": "error_handler"
        },
        {
            "location": "/api/application/#url",
            "text": "Defines the URL on which the application will be hosted. Should include port.  Input:   string  application {\n    ...\n    url \"http://0.0.0.0:8085/\"\n}",
            "title": "url"
        },
        {
            "location": "/api/application/#memory_cache",
            "text": "Enables in-memory session cache. Required if you used  fetchSession  plug.  application {\n    ...\n    memory_cache\n}",
            "title": "memory_cache"
        },
        {
            "location": "/api/application/#use_gzip",
            "text": "Enables automatic gzip compression.  application {\n    ...\n    use_gzip\n}",
            "title": "use_gzip"
        },
        {
            "location": "/api/application/#use_static",
            "text": "Enables static file hosting. Input path defines  WebRoot  and  ContentRoot  of application.  Input:   string  application {\n    ...\n    use_static \"static\"\n}",
            "title": "use_static"
        },
        {
            "location": "/api/application/#use_config",
            "text": "Defines configuration that can be used with the  HttpContext.GetConfiguration()  function. The configuration function is evaluated once, during first request of the application.  Input:   unit -> 'a  application {\n    ...\n    use_config (fun _ -> \"config\")\n}",
            "title": "use_config"
        },
        {
            "location": "/api/application/#force_ssl",
            "text": "Redirect all HTTP request to HTTPS.  application {\n    ...\n    force_ssl\n}",
            "title": "force_ssl"
        },
        {
            "location": "/api/application/#use_cors",
            "text": "Enables application level CORS protection. First parameter is the name of the policy. Second parameter is configuration builder setting policy options.  Input:   string -> (CorsPolicyBuilder -> unit)  application {\n    ...\n    use_cors \"CORS_policy\" (fun builder -> ())\n}",
            "title": "use_cors"
        },
        {
            "location": "/api/application/#use_iis",
            "text": "Enables IIS integration.  application {\n    ...\n    use_iis\n}",
            "title": "use_iis"
        },
        {
            "location": "/api/application/#use_jwt_authentication",
            "text": "Enables default JWT authentication. The first parameter is a private key used in signing. The second one defines the issuer of the token.  Input:   string -> string  application {\n    ...\n    use_jwt_authentication \"mySecretKey\" \"lambdafactory.io\"\n}",
            "title": "use_jwt_authentication"
        },
        {
            "location": "/api/application/#use_jwt_authentication_with_config",
            "text": "Enables JWT authentication with custom configuration.  Input:   JwtBearerOptions -> unit  application {\n    ...\n    use_jwt_authentication_with_config (fun opts -> ())\n}",
            "title": "use_jwt_authentication_with_config"
        },
        {
            "location": "/api/application/#use_cookies_authentication",
            "text": "Enables default cookies authentication.  Input:   string  application {\n    ...\n    use_cookies_authentication \"lambdafactory.io\"\n}",
            "title": "use_cookies_authentication"
        },
        {
            "location": "/api/application/#use_cookies_authentication_with_config",
            "text": "Enables cookies authentication with custom configuration.  Input:   CookieAuthenticationOptions -> unit  application {\n    ...\n    use_cookies_authentication_with_config (fun opts -> ())\n}",
            "title": "use_cookies_authentication_with_config"
        },
        {
            "location": "/api/application/#use_github_oauth",
            "text": "Enables default GitHub OAuth authentication.  Input:   string -> string -> string  application {\n    ...\n    use_github_oauth \"myClientId\" \"myClientSecret\" \"/login\"\n}",
            "title": "use_github_oauth"
        },
        {
            "location": "/api/application/#use_github_oauth_with_config",
            "text": "Enables GitHub OAuth authentication with custom configuration.  Input:   OAuthOptions -> unit  application {\n    ...\n    use_github_oauth (fun opts -> ())\n}",
            "title": "use_github_oauth_with_config"
        },
        {
            "location": "/api/application/#use_custom_oauth",
            "text": "Enables custom OAuth authentication.  Input:   string -> (OAuthOptions -> unit)  application {\n    ...\n    use_custom_oauth \"LinkedIn\" (fun opts -> ())\n}    The functions below enable you to add any configuration using standard ASP.NET builders",
            "title": "use_custom_oauth"
        },
        {
            "location": "/api/application/#app_config",
            "text": "Adds custom application configuration step.  Input:   IApplicationBuilder -> IApplicationBuilder",
            "title": "app_config"
        },
        {
            "location": "/api/application/#host_config",
            "text": "Adds custom host configuration step.  Input:   IWebHostBuilder -> IWebHostBuilder",
            "title": "host_config"
        },
        {
            "location": "/api/application/#service_config",
            "text": "Adds custom service configuration step.  Input:   IServiceCollection -> IServiceCollection  let serviceConfig (services: IServiceCollection) =\n    services.AddSingleton<IMySingleton, MySingleton>()\n    services.AddTransient<SomeTransientService>()\n\nlet app = application {\n    ...\n    service_config serviceConfig\n}",
            "title": "service_config"
        },
        {
            "location": "/api/application/#logging",
            "text": "Adds logging configuration.  Input:   IloggingBuilder -> unit",
            "title": "logging"
        }
    ]
}